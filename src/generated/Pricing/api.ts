/* tslint:disable */
/* eslint-disable */
/**
 * SaaSus Pricing API Schema
 * SaaSus Pricing API Schema
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Aggregate usage sum: Total usage during the period max: Maximum usage during the period 
 * @export
 * @enum {string}
 */

export const AggregateUsage = {
    Sum: 'sum',
    Max: 'max'
} as const;

export type AggregateUsage = typeof AggregateUsage[keyof typeof AggregateUsage];


/**
 * Unit of currency
 * @export
 * @enum {string}
 */

export const Currency = {
    Jpy: 'JPY',
    Usd: 'USD'
} as const;

export type Currency = typeof Currency[keyof typeof Currency];


/**
 * 
 * @export
 * @interface MeteringUnit
 */
export interface MeteringUnit {
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof MeteringUnit
     */
    'id': string;
    /**
     * Metering unit used settings
     * @type {boolean}
     * @memberof MeteringUnit
     */
    'used': boolean;
    /**
     * Metering unit name
     * @type {string}
     * @memberof MeteringUnit
     */
    'unit_name': string;
    /**
     * 
     * @type {AggregateUsage}
     * @memberof MeteringUnit
     */
    'aggregate_usage'?: AggregateUsage;
    /**
     * Display name
     * @type {string}
     * @memberof MeteringUnit
     */
    'display_name': string;
    /**
     * Description
     * @type {string}
     * @memberof MeteringUnit
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface MeteringUnitAllOf
 */
export interface MeteringUnitAllOf {
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof MeteringUnitAllOf
     */
    'id': string;
    /**
     * Metering unit used settings
     * @type {boolean}
     * @memberof MeteringUnitAllOf
     */
    'used': boolean;
}
/**
 * 
 * @export
 * @interface MeteringUnitCount
 */
export interface MeteringUnitCount {
    /**
     * Timestamp
     * @type {number}
     * @memberof MeteringUnitCount
     */
    'timestamp': number;
    /**
     * Count
     * @type {number}
     * @memberof MeteringUnitCount
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface MeteringUnitDateCount
 */
export interface MeteringUnitDateCount {
    /**
     * Metering unit name
     * @type {string}
     * @memberof MeteringUnitDateCount
     */
    'metering_unit_name': string;
    /**
     * Date
     * @type {string}
     * @memberof MeteringUnitDateCount
     */
    'date': string;
    /**
     * Count
     * @type {number}
     * @memberof MeteringUnitDateCount
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface MeteringUnitDateCounts
 */
export interface MeteringUnitDateCounts {
    /**
     * 
     * @type {Array<MeteringUnitDateCount>}
     * @memberof MeteringUnitDateCounts
     */
    'counts': Array<MeteringUnitDateCount>;
}
/**
 * 
 * @export
 * @interface MeteringUnitDatePeriodCounts
 */
export interface MeteringUnitDatePeriodCounts {
    /**
     * Metering unit name
     * @type {string}
     * @memberof MeteringUnitDatePeriodCounts
     */
    'metering_unit_name': string;
    /**
     * 
     * @type {Array<MeteringUnitCount>}
     * @memberof MeteringUnitDatePeriodCounts
     */
    'counts': Array<MeteringUnitCount>;
}
/**
 * 
 * @export
 * @interface MeteringUnitMonthCount
 */
export interface MeteringUnitMonthCount {
    /**
     * Metering unit name
     * @type {string}
     * @memberof MeteringUnitMonthCount
     */
    'metering_unit_name': string;
    /**
     * Month
     * @type {string}
     * @memberof MeteringUnitMonthCount
     */
    'month': string;
    /**
     * Count
     * @type {number}
     * @memberof MeteringUnitMonthCount
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface MeteringUnitMonthCounts
 */
export interface MeteringUnitMonthCounts {
    /**
     * 
     * @type {Array<MeteringUnitMonthCount>}
     * @memberof MeteringUnitMonthCounts
     */
    'counts': Array<MeteringUnitMonthCount>;
}
/**
 * 
 * @export
 * @interface MeteringUnitProps
 */
export interface MeteringUnitProps {
    /**
     * Metering unit name
     * @type {string}
     * @memberof MeteringUnitProps
     */
    'unit_name': string;
    /**
     * 
     * @type {AggregateUsage}
     * @memberof MeteringUnitProps
     */
    'aggregate_usage'?: AggregateUsage;
    /**
     * Display name
     * @type {string}
     * @memberof MeteringUnitProps
     */
    'display_name': string;
    /**
     * Description
     * @type {string}
     * @memberof MeteringUnitProps
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface MeteringUnitTimestampCount
 */
export interface MeteringUnitTimestampCount {
    /**
     * Metering unit name
     * @type {string}
     * @memberof MeteringUnitTimestampCount
     */
    'metering_unit_name': string;
    /**
     * Timestamp
     * @type {number}
     * @memberof MeteringUnitTimestampCount
     */
    'timestamp': number;
    /**
     * Count
     * @type {number}
     * @memberof MeteringUnitTimestampCount
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface MeteringUnits
 */
export interface MeteringUnits {
    /**
     * 
     * @type {Array<MeteringUnit>}
     * @memberof MeteringUnits
     */
    'units': Array<MeteringUnit>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Error type
     * @type {string}
     * @memberof ModelError
     */
    'type': string;
    /**
     * Error message
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface PricingFixedUnit
 */
export interface PricingFixedUnit {
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof PricingFixedUnit
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof PricingFixedUnit
     */
    'used': boolean;
    /**
     * Price
     * @type {number}
     * @memberof PricingFixedUnit
     */
    'unit_amount': number;
    /**
     * 
     * @type {RecurringInterval}
     * @memberof PricingFixedUnit
     */
    'recurring_interval': RecurringInterval;
    /**
     * Name
     * @type {string}
     * @memberof PricingFixedUnit
     */
    'name': string;
    /**
     * Display Name
     * @type {string}
     * @memberof PricingFixedUnit
     */
    'display_name': string;
    /**
     * Description
     * @type {string}
     * @memberof PricingFixedUnit
     */
    'description': string;
    /**
     * 
     * @type {UnitType}
     * @memberof PricingFixedUnit
     */
    'type': UnitType;
    /**
     * 
     * @type {Currency}
     * @memberof PricingFixedUnit
     */
    'currency': Currency;
}
/**
 * 
 * @export
 * @interface PricingFixedUnitAllOf
 */
export interface PricingFixedUnitAllOf {
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof PricingFixedUnitAllOf
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof PricingFixedUnitAllOf
     */
    'used': boolean;
}
/**
 * 
 * @export
 * @interface PricingFixedUnitForSave
 */
export interface PricingFixedUnitForSave {
    /**
     * Price
     * @type {number}
     * @memberof PricingFixedUnitForSave
     */
    'unit_amount': number;
    /**
     * 
     * @type {RecurringInterval}
     * @memberof PricingFixedUnitForSave
     */
    'recurring_interval': RecurringInterval;
    /**
     * Name
     * @type {string}
     * @memberof PricingFixedUnitForSave
     */
    'name': string;
    /**
     * Display Name
     * @type {string}
     * @memberof PricingFixedUnitForSave
     */
    'display_name': string;
    /**
     * Description
     * @type {string}
     * @memberof PricingFixedUnitForSave
     */
    'description': string;
    /**
     * 
     * @type {UnitType}
     * @memberof PricingFixedUnitForSave
     */
    'type': UnitType;
    /**
     * 
     * @type {Currency}
     * @memberof PricingFixedUnitForSave
     */
    'currency': Currency;
}
/**
 * 
 * @export
 * @interface PricingFixedUnitForSaveAllOf
 */
export interface PricingFixedUnitForSaveAllOf {
    /**
     * Price
     * @type {number}
     * @memberof PricingFixedUnitForSaveAllOf
     */
    'unit_amount': number;
    /**
     * 
     * @type {RecurringInterval}
     * @memberof PricingFixedUnitForSaveAllOf
     */
    'recurring_interval': RecurringInterval;
}
/**
 * 
 * @export
 * @interface PricingMenu
 */
export interface PricingMenu {
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof PricingMenu
     */
    'id': string;
    /**
     * Menu name
     * @type {string}
     * @memberof PricingMenu
     */
    'name': string;
    /**
     * Menu display name
     * @type {string}
     * @memberof PricingMenu
     */
    'display_name': string;
    /**
     * Menu description
     * @type {string}
     * @memberof PricingMenu
     */
    'description': string;
    /**
     * Menu used settings
     * @type {boolean}
     * @memberof PricingMenu
     */
    'used': boolean;
    /**
     * 
     * @type {Array<PricingUnit>}
     * @memberof PricingMenu
     */
    'units': Array<PricingUnit>;
}
/**
 * 
 * @export
 * @interface PricingMenuAllOf
 */
export interface PricingMenuAllOf {
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof PricingMenuAllOf
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface PricingMenuProps
 */
export interface PricingMenuProps {
    /**
     * Menu name
     * @type {string}
     * @memberof PricingMenuProps
     */
    'name': string;
    /**
     * Menu display name
     * @type {string}
     * @memberof PricingMenuProps
     */
    'display_name': string;
    /**
     * Menu description
     * @type {string}
     * @memberof PricingMenuProps
     */
    'description': string;
    /**
     * Menu used settings
     * @type {boolean}
     * @memberof PricingMenuProps
     */
    'used': boolean;
    /**
     * 
     * @type {Array<PricingUnit>}
     * @memberof PricingMenuProps
     */
    'units': Array<PricingUnit>;
}
/**
 * 
 * @export
 * @interface PricingMenuPropsAllOf
 */
export interface PricingMenuPropsAllOf {
    /**
     * Menu name
     * @type {string}
     * @memberof PricingMenuPropsAllOf
     */
    'name': string;
    /**
     * Menu display name
     * @type {string}
     * @memberof PricingMenuPropsAllOf
     */
    'display_name': string;
    /**
     * Menu description
     * @type {string}
     * @memberof PricingMenuPropsAllOf
     */
    'description': string;
    /**
     * Menu used settings
     * @type {boolean}
     * @memberof PricingMenuPropsAllOf
     */
    'used': boolean;
}
/**
 * 
 * @export
 * @interface PricingMenus
 */
export interface PricingMenus {
    /**
     * 
     * @type {Array<PricingMenu>}
     * @memberof PricingMenus
     */
    'pricing_menus': Array<PricingMenu>;
}
/**
 * 
 * @export
 * @interface PricingPlan
 */
export interface PricingPlan {
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof PricingPlan
     */
    'id': string;
    /**
     * Pricing plan name
     * @type {string}
     * @memberof PricingPlan
     */
    'name': string;
    /**
     * Pricing plan display name
     * @type {string}
     * @memberof PricingPlan
     */
    'display_name': string;
    /**
     * Pricing plan description
     * @type {string}
     * @memberof PricingPlan
     */
    'description': string;
    /**
     * Pricing plan used settings
     * @type {boolean}
     * @memberof PricingPlan
     */
    'used': boolean;
    /**
     * 
     * @type {Array<PricingMenu>}
     * @memberof PricingPlan
     */
    'pricing_menus': Array<PricingMenu>;
}
/**
 * 
 * @export
 * @interface PricingPlanProps
 */
export interface PricingPlanProps {
    /**
     * Pricing plan name
     * @type {string}
     * @memberof PricingPlanProps
     */
    'name': string;
    /**
     * Pricing plan display name
     * @type {string}
     * @memberof PricingPlanProps
     */
    'display_name': string;
    /**
     * Pricing plan description
     * @type {string}
     * @memberof PricingPlanProps
     */
    'description': string;
    /**
     * Pricing plan used settings
     * @type {boolean}
     * @memberof PricingPlanProps
     */
    'used': boolean;
    /**
     * 
     * @type {Array<PricingMenu>}
     * @memberof PricingPlanProps
     */
    'pricing_menus': Array<PricingMenu>;
}
/**
 * 
 * @export
 * @interface PricingPlanPropsAllOf
 */
export interface PricingPlanPropsAllOf {
    /**
     * Pricing plan name
     * @type {string}
     * @memberof PricingPlanPropsAllOf
     */
    'name': string;
    /**
     * Pricing plan display name
     * @type {string}
     * @memberof PricingPlanPropsAllOf
     */
    'display_name': string;
    /**
     * Pricing plan description
     * @type {string}
     * @memberof PricingPlanPropsAllOf
     */
    'description': string;
    /**
     * Pricing plan used settings
     * @type {boolean}
     * @memberof PricingPlanPropsAllOf
     */
    'used': boolean;
}
/**
 * 
 * @export
 * @interface PricingPlans
 */
export interface PricingPlans {
    /**
     * 
     * @type {Array<PricingPlan>}
     * @memberof PricingPlans
     */
    'pricing_plans': Array<PricingPlan>;
}
/**
 * 
 * @export
 * @interface PricingTier
 */
export interface PricingTier {
    /**
     * Upper limit
     * @type {number}
     * @memberof PricingTier
     */
    'up_to': number;
    /**
     * Amount per unit
     * @type {number}
     * @memberof PricingTier
     */
    'unit_amount': number;
    /**
     * Fixed amount
     * @type {number}
     * @memberof PricingTier
     */
    'flat_amount': number;
    /**
     * Indefinite
     * @type {boolean}
     * @memberof PricingTier
     */
    'inf': boolean;
}
/**
 * 
 * @export
 * @interface PricingTieredUnit
 */
export interface PricingTieredUnit {
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof PricingTieredUnit
     */
    'id': string;
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof PricingTieredUnit
     */
    'metering_unit_id': string;
    /**
     * 
     * @type {RecurringInterval}
     * @memberof PricingTieredUnit
     */
    'recurring_interval': RecurringInterval;
    /**
     * Indicates if the unit is used
     * @type {boolean}
     * @memberof PricingTieredUnit
     */
    'used': boolean;
    /**
     * Upper limit
     * @type {number}
     * @memberof PricingTieredUnit
     */
    'upper_count': number;
    /**
     * Metering unit name
     * @type {string}
     * @memberof PricingTieredUnit
     */
    'metering_unit_name': string;
    /**
     * 
     * @type {AggregateUsage}
     * @memberof PricingTieredUnit
     */
    'aggregate_usage'?: AggregateUsage;
    /**
     * Name
     * @type {string}
     * @memberof PricingTieredUnit
     */
    'name': string;
    /**
     * Display Name
     * @type {string}
     * @memberof PricingTieredUnit
     */
    'display_name': string;
    /**
     * Description
     * @type {string}
     * @memberof PricingTieredUnit
     */
    'description': string;
    /**
     * 
     * @type {UnitType}
     * @memberof PricingTieredUnit
     */
    'type': UnitType;
    /**
     * 
     * @type {Currency}
     * @memberof PricingTieredUnit
     */
    'currency': Currency;
    /**
     * 
     * @type {Array<PricingTier>}
     * @memberof PricingTieredUnit
     */
    'tiers': Array<PricingTier>;
}
/**
 * 
 * @export
 * @interface PricingTieredUnitForSave
 */
export interface PricingTieredUnitForSave {
    /**
     * Upper limit
     * @type {number}
     * @memberof PricingTieredUnitForSave
     */
    'upper_count': number;
    /**
     * Metering unit name
     * @type {string}
     * @memberof PricingTieredUnitForSave
     */
    'metering_unit_name': string;
    /**
     * 
     * @type {AggregateUsage}
     * @memberof PricingTieredUnitForSave
     */
    'aggregate_usage'?: AggregateUsage;
    /**
     * Name
     * @type {string}
     * @memberof PricingTieredUnitForSave
     */
    'name': string;
    /**
     * Display Name
     * @type {string}
     * @memberof PricingTieredUnitForSave
     */
    'display_name': string;
    /**
     * Description
     * @type {string}
     * @memberof PricingTieredUnitForSave
     */
    'description': string;
    /**
     * 
     * @type {UnitType}
     * @memberof PricingTieredUnitForSave
     */
    'type': UnitType;
    /**
     * 
     * @type {Currency}
     * @memberof PricingTieredUnitForSave
     */
    'currency': Currency;
    /**
     * 
     * @type {Array<PricingTier>}
     * @memberof PricingTieredUnitForSave
     */
    'tiers': Array<PricingTier>;
}
/**
 * 
 * @export
 * @interface PricingTieredUsageUnit
 */
export interface PricingTieredUsageUnit {
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof PricingTieredUsageUnit
     */
    'id': string;
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof PricingTieredUsageUnit
     */
    'metering_unit_id': string;
    /**
     * 
     * @type {RecurringInterval}
     * @memberof PricingTieredUsageUnit
     */
    'recurring_interval': RecurringInterval;
    /**
     * Indicates if the unit is used
     * @type {boolean}
     * @memberof PricingTieredUsageUnit
     */
    'used': boolean;
    /**
     * Upper limit
     * @type {number}
     * @memberof PricingTieredUsageUnit
     */
    'upper_count': number;
    /**
     * Metering unit name
     * @type {string}
     * @memberof PricingTieredUsageUnit
     */
    'metering_unit_name': string;
    /**
     * 
     * @type {AggregateUsage}
     * @memberof PricingTieredUsageUnit
     */
    'aggregate_usage'?: AggregateUsage;
    /**
     * Name
     * @type {string}
     * @memberof PricingTieredUsageUnit
     */
    'name': string;
    /**
     * Display Name
     * @type {string}
     * @memberof PricingTieredUsageUnit
     */
    'display_name': string;
    /**
     * Description
     * @type {string}
     * @memberof PricingTieredUsageUnit
     */
    'description': string;
    /**
     * 
     * @type {UnitType}
     * @memberof PricingTieredUsageUnit
     */
    'type': UnitType;
    /**
     * 
     * @type {Currency}
     * @memberof PricingTieredUsageUnit
     */
    'currency': Currency;
    /**
     * 
     * @type {Array<PricingTier>}
     * @memberof PricingTieredUsageUnit
     */
    'tiers': Array<PricingTier>;
}
/**
 * 
 * @export
 * @interface PricingTieredUsageUnitAllOf
 */
export interface PricingTieredUsageUnitAllOf {
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof PricingTieredUsageUnitAllOf
     */
    'id': string;
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof PricingTieredUsageUnitAllOf
     */
    'metering_unit_id': string;
    /**
     * 
     * @type {RecurringInterval}
     * @memberof PricingTieredUsageUnitAllOf
     */
    'recurring_interval': RecurringInterval;
    /**
     * Indicates if the unit is used
     * @type {boolean}
     * @memberof PricingTieredUsageUnitAllOf
     */
    'used': boolean;
}
/**
 * 
 * @export
 * @interface PricingTieredUsageUnitForSave
 */
export interface PricingTieredUsageUnitForSave {
    /**
     * Upper limit
     * @type {number}
     * @memberof PricingTieredUsageUnitForSave
     */
    'upper_count': number;
    /**
     * Metering unit name
     * @type {string}
     * @memberof PricingTieredUsageUnitForSave
     */
    'metering_unit_name': string;
    /**
     * 
     * @type {AggregateUsage}
     * @memberof PricingTieredUsageUnitForSave
     */
    'aggregate_usage'?: AggregateUsage;
    /**
     * Name
     * @type {string}
     * @memberof PricingTieredUsageUnitForSave
     */
    'name': string;
    /**
     * Display Name
     * @type {string}
     * @memberof PricingTieredUsageUnitForSave
     */
    'display_name': string;
    /**
     * Description
     * @type {string}
     * @memberof PricingTieredUsageUnitForSave
     */
    'description': string;
    /**
     * 
     * @type {UnitType}
     * @memberof PricingTieredUsageUnitForSave
     */
    'type': UnitType;
    /**
     * 
     * @type {Currency}
     * @memberof PricingTieredUsageUnitForSave
     */
    'currency': Currency;
    /**
     * 
     * @type {Array<PricingTier>}
     * @memberof PricingTieredUsageUnitForSave
     */
    'tiers': Array<PricingTier>;
}
/**
 * 
 * @export
 * @interface PricingTieredUsageUnitForSaveAllOf
 */
export interface PricingTieredUsageUnitForSaveAllOf {
    /**
     * Upper limit
     * @type {number}
     * @memberof PricingTieredUsageUnitForSaveAllOf
     */
    'upper_count': number;
    /**
     * Metering unit name
     * @type {string}
     * @memberof PricingTieredUsageUnitForSaveAllOf
     */
    'metering_unit_name': string;
    /**
     * 
     * @type {AggregateUsage}
     * @memberof PricingTieredUsageUnitForSaveAllOf
     */
    'aggregate_usage'?: AggregateUsage;
}
/**
 * 
 * @export
 * @interface PricingTiers
 */
export interface PricingTiers {
    /**
     * 
     * @type {Array<PricingTier>}
     * @memberof PricingTiers
     */
    'tiers': Array<PricingTier>;
}
/**
 * @type PricingUnit
 * @export
 */
export type PricingUnit = { type: 'fixed' } & PricingFixedUnit | { type: 'tiered' } & PricingTieredUnit | { type: 'tiered_usage' } & PricingTieredUsageUnit | { type: 'usage' } & PricingUsageUnit;

/**
 * 
 * @export
 * @interface PricingUnitBaseProps
 */
export interface PricingUnitBaseProps {
    /**
     * Name
     * @type {string}
     * @memberof PricingUnitBaseProps
     */
    'name': string;
    /**
     * Display Name
     * @type {string}
     * @memberof PricingUnitBaseProps
     */
    'display_name': string;
    /**
     * Description
     * @type {string}
     * @memberof PricingUnitBaseProps
     */
    'description': string;
    /**
     * 
     * @type {UnitType}
     * @memberof PricingUnitBaseProps
     */
    'type': UnitType;
    /**
     * 
     * @type {Currency}
     * @memberof PricingUnitBaseProps
     */
    'currency': Currency;
}
/**
 * @type PricingUnitForSave
 * @export
 */
export type PricingUnitForSave = { type: 'fixed' } & PricingFixedUnitForSave | { type: 'tiered' } & PricingTieredUnitForSave | { type: 'tiered_usage' } & PricingTieredUsageUnitForSave | { type: 'usage' } & PricingUsageUnitForSave;

/**
 * 
 * @export
 * @interface PricingUnits
 */
export interface PricingUnits {
    /**
     * 
     * @type {Array<PricingUnit>}
     * @memberof PricingUnits
     */
    'units': Array<PricingUnit>;
}
/**
 * 
 * @export
 * @interface PricingUsageUnit
 */
export interface PricingUsageUnit {
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof PricingUsageUnit
     */
    'id': string;
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof PricingUsageUnit
     */
    'metering_unit_id': string;
    /**
     * 
     * @type {RecurringInterval}
     * @memberof PricingUsageUnit
     */
    'recurring_interval': RecurringInterval;
    /**
     * 
     * @type {boolean}
     * @memberof PricingUsageUnit
     */
    'used': boolean;
    /**
     * Upper limit
     * @type {number}
     * @memberof PricingUsageUnit
     */
    'upper_count': number;
    /**
     * Amount per usage
     * @type {number}
     * @memberof PricingUsageUnit
     */
    'unit_amount': number;
    /**
     * Metering unit name
     * @type {string}
     * @memberof PricingUsageUnit
     */
    'metering_unit_name': string;
    /**
     * 
     * @type {AggregateUsage}
     * @memberof PricingUsageUnit
     */
    'aggregate_usage'?: AggregateUsage;
    /**
     * Name
     * @type {string}
     * @memberof PricingUsageUnit
     */
    'name': string;
    /**
     * Display Name
     * @type {string}
     * @memberof PricingUsageUnit
     */
    'display_name': string;
    /**
     * Description
     * @type {string}
     * @memberof PricingUsageUnit
     */
    'description': string;
    /**
     * 
     * @type {UnitType}
     * @memberof PricingUsageUnit
     */
    'type': UnitType;
    /**
     * 
     * @type {Currency}
     * @memberof PricingUsageUnit
     */
    'currency': Currency;
}
/**
 * 
 * @export
 * @interface PricingUsageUnitAllOf
 */
export interface PricingUsageUnitAllOf {
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof PricingUsageUnitAllOf
     */
    'id': string;
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof PricingUsageUnitAllOf
     */
    'metering_unit_id': string;
    /**
     * 
     * @type {RecurringInterval}
     * @memberof PricingUsageUnitAllOf
     */
    'recurring_interval': RecurringInterval;
    /**
     * 
     * @type {boolean}
     * @memberof PricingUsageUnitAllOf
     */
    'used': boolean;
}
/**
 * 
 * @export
 * @interface PricingUsageUnitForSave
 */
export interface PricingUsageUnitForSave {
    /**
     * Upper limit
     * @type {number}
     * @memberof PricingUsageUnitForSave
     */
    'upper_count': number;
    /**
     * Amount per usage
     * @type {number}
     * @memberof PricingUsageUnitForSave
     */
    'unit_amount': number;
    /**
     * Metering unit name
     * @type {string}
     * @memberof PricingUsageUnitForSave
     */
    'metering_unit_name': string;
    /**
     * 
     * @type {AggregateUsage}
     * @memberof PricingUsageUnitForSave
     */
    'aggregate_usage'?: AggregateUsage;
    /**
     * Name
     * @type {string}
     * @memberof PricingUsageUnitForSave
     */
    'name': string;
    /**
     * Display Name
     * @type {string}
     * @memberof PricingUsageUnitForSave
     */
    'display_name': string;
    /**
     * Description
     * @type {string}
     * @memberof PricingUsageUnitForSave
     */
    'description': string;
    /**
     * 
     * @type {UnitType}
     * @memberof PricingUsageUnitForSave
     */
    'type': UnitType;
    /**
     * 
     * @type {Currency}
     * @memberof PricingUsageUnitForSave
     */
    'currency': Currency;
}
/**
 * 
 * @export
 * @interface PricingUsageUnitForSaveAllOf
 */
export interface PricingUsageUnitForSaveAllOf {
    /**
     * Upper limit
     * @type {number}
     * @memberof PricingUsageUnitForSaveAllOf
     */
    'upper_count': number;
    /**
     * Amount per usage
     * @type {number}
     * @memberof PricingUsageUnitForSaveAllOf
     */
    'unit_amount': number;
    /**
     * Metering unit name
     * @type {string}
     * @memberof PricingUsageUnitForSaveAllOf
     */
    'metering_unit_name': string;
    /**
     * 
     * @type {AggregateUsage}
     * @memberof PricingUsageUnitForSaveAllOf
     */
    'aggregate_usage'?: AggregateUsage;
}
/**
 * Cycle month: Monthly year: Yearly 
 * @export
 * @enum {string}
 */

export const RecurringInterval = {
    Month: 'month',
    Year: 'year'
} as const;

export type RecurringInterval = typeof RecurringInterval[keyof typeof RecurringInterval];


/**
 * 
 * @export
 * @interface SavePricingMenuParam
 */
export interface SavePricingMenuParam {
    /**
     * Menu name
     * @type {string}
     * @memberof SavePricingMenuParam
     */
    'name': string;
    /**
     * Menu display name
     * @type {string}
     * @memberof SavePricingMenuParam
     */
    'display_name': string;
    /**
     * Menu description
     * @type {string}
     * @memberof SavePricingMenuParam
     */
    'description': string;
    /**
     * Unit IDs to add
     * @type {Array<string>}
     * @memberof SavePricingMenuParam
     */
    'unit_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface SavePricingPlanParam
 */
export interface SavePricingPlanParam {
    /**
     * Pricing plan name
     * @type {string}
     * @memberof SavePricingPlanParam
     */
    'name': string;
    /**
     * Pricing plan display name
     * @type {string}
     * @memberof SavePricingPlanParam
     */
    'display_name': string;
    /**
     * Pricing plan description
     * @type {string}
     * @memberof SavePricingPlanParam
     */
    'description': string;
    /**
     * Menu ID to be added to the pricing plan
     * @type {Array<string>}
     * @memberof SavePricingPlanParam
     */
    'menu_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface TaxRate
 */
export interface TaxRate {
    /**
     * Universally Unique Identifier
     * @type {string}
     * @memberof TaxRate
     */
    'id': string;
    /**
     * Name of tax rate
     * @type {string}
     * @memberof TaxRate
     */
    'name': string;
    /**
     * Display name
     * @type {string}
     * @memberof TaxRate
     */
    'display_name': string;
    /**
     * Percentage
     * @type {number}
     * @memberof TaxRate
     */
    'percentage': number;
    /**
     * Inclusive or not
     * @type {boolean}
     * @memberof TaxRate
     */
    'inclusive': boolean;
    /**
     * Country code of ISO 3166-1 alpha-2
     * @type {string}
     * @memberof TaxRate
     */
    'country': string;
    /**
     * Description
     * @type {string}
     * @memberof TaxRate
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface TaxRateProps
 */
export interface TaxRateProps {
    /**
     * Name of tax rate
     * @type {string}
     * @memberof TaxRateProps
     */
    'name': string;
    /**
     * Display name
     * @type {string}
     * @memberof TaxRateProps
     */
    'display_name': string;
    /**
     * Percentage
     * @type {number}
     * @memberof TaxRateProps
     */
    'percentage': number;
    /**
     * Inclusive or not
     * @type {boolean}
     * @memberof TaxRateProps
     */
    'inclusive': boolean;
    /**
     * Country code of ISO 3166-1 alpha-2
     * @type {string}
     * @memberof TaxRateProps
     */
    'country': string;
    /**
     * Description
     * @type {string}
     * @memberof TaxRateProps
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface TaxRates
 */
export interface TaxRates {
    /**
     * 
     * @type {Array<TaxRate>}
     * @memberof TaxRates
     */
    'tax_rates': Array<TaxRate>;
}
/**
 * Unit of measurement type fixed: Fixed unit usage: Usage unit tiered: Tiered unit tiered_usage: Tiered usage unit 
 * @export
 * @enum {string}
 */

export const UnitType = {
    Fixed: 'fixed',
    Usage: 'usage',
    Tiered: 'tiered',
    TieredUsage: 'tiered_usage'
} as const;

export type UnitType = typeof UnitType[keyof typeof UnitType];


/**
 * Update method add: Addition sub: Subtraction direct: Overwrite 
 * @export
 * @enum {string}
 */

export const UpdateMeteringUnitTimestampCountMethod = {
    Add: 'add',
    Sub: 'sub',
    Direct: 'direct'
} as const;

export type UpdateMeteringUnitTimestampCountMethod = typeof UpdateMeteringUnitTimestampCountMethod[keyof typeof UpdateMeteringUnitTimestampCountMethod];


/**
 * 
 * @export
 * @interface UpdateMeteringUnitTimestampCountNowParam
 */
export interface UpdateMeteringUnitTimestampCountNowParam {
    /**
     * 
     * @type {UpdateMeteringUnitTimestampCountMethod}
     * @memberof UpdateMeteringUnitTimestampCountNowParam
     */
    'method': UpdateMeteringUnitTimestampCountMethod;
    /**
     * Count
     * @type {number}
     * @memberof UpdateMeteringUnitTimestampCountNowParam
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface UpdateMeteringUnitTimestampCountParam
 */
export interface UpdateMeteringUnitTimestampCountParam {
    /**
     * 
     * @type {UpdateMeteringUnitTimestampCountMethod}
     * @memberof UpdateMeteringUnitTimestampCountParam
     */
    'method': UpdateMeteringUnitTimestampCountMethod;
    /**
     * Count
     * @type {number}
     * @memberof UpdateMeteringUnitTimestampCountParam
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface UpdatePricingPlansUsedParam
 */
export interface UpdatePricingPlansUsedParam {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdatePricingPlansUsedParam
     */
    'plan_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateTaxRateParam
 */
export interface UpdateTaxRateParam {
    /**
     * Display name
     * @type {string}
     * @memberof UpdateTaxRateParam
     */
    'display_name': string;
    /**
     * Description
     * @type {string}
     * @memberof UpdateTaxRateParam
     */
    'description': string;
}

/**
 * ErrorApi - axios parameter creator
 * @export
 */
export const ErrorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint is used for testing purposes. Returns a server error with status code 500. 
         * @summary Return Internal Server Error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnInternalServerError: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/errors/internal-server-error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ErrorApi - functional programming interface
 * @export
 */
export const ErrorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ErrorApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint is used for testing purposes. Returns a server error with status code 500. 
         * @summary Return Internal Server Error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async returnInternalServerError(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.returnInternalServerError(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ErrorApi - factory interface
 * @export
 */
export const ErrorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ErrorApiFp(configuration)
    return {
        /**
         * This endpoint is used for testing purposes. Returns a server error with status code 500. 
         * @summary Return Internal Server Error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnInternalServerError(options?: any): AxiosPromise<void> {
            return localVarFp.returnInternalServerError(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ErrorApi - object-oriented interface
 * @export
 * @class ErrorApi
 * @extends {BaseAPI}
 */
export class ErrorApi extends BaseAPI {
    /**
     * This endpoint is used for testing purposes. Returns a server error with status code 500. 
     * @summary Return Internal Server Error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorApi
     */
    public returnInternalServerError(options?: AxiosRequestConfig) {
        return ErrorApiFp(this.configuration).returnInternalServerError(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MeteringApi - axios parameter creator
 * @export
 */
export const MeteringApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a metering unit. 
         * @summary Create Metering Unit
         * @param {MeteringUnitProps} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMeteringUnit: async (body?: MeteringUnitProps, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metering/units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete metering unit. 
         * @summary Delete Metering Unit
         * @param {string} meteringUnitId Metering Unit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeteringUnitByID: async (meteringUnitId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'meteringUnitId' is not null or undefined
            assertParamExists('deleteMeteringUnitByID', 'meteringUnitId', meteringUnitId)
            const localVarPath = `/metering/units/{metering_unit_id}`
                .replace(`{${"metering_unit_id"}}`, encodeURIComponent(String(meteringUnitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes metering unit count for the specified timestamp. 
         * @summary Delete Metering Unit Count for Specified Timestamp
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {number} timestamp Timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeteringUnitTimestampCount: async (tenantId: string, meteringUnitName: string, timestamp: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('deleteMeteringUnitTimestampCount', 'tenantId', tenantId)
            // verify required parameter 'meteringUnitName' is not null or undefined
            assertParamExists('deleteMeteringUnitTimestampCount', 'meteringUnitName', meteringUnitName)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('deleteMeteringUnitTimestampCount', 'timestamp', timestamp)
            const localVarPath = `/metering/tenants/{tenant_id}/units/{metering_unit_name}/timestamp/{timestamp}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"metering_unit_name"}}`, encodeURIComponent(String(meteringUnitName)))
                .replace(`{${"timestamp"}}`, encodeURIComponent(String(timestamp)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the metering unit count for a specific date. 
         * @summary Get Metering Unit Count for Specific Date
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {string} date Date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeteringUnitDateCountByTenantIdAndUnitNameAndDate: async (tenantId: string, meteringUnitName: string, date: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getMeteringUnitDateCountByTenantIdAndUnitNameAndDate', 'tenantId', tenantId)
            // verify required parameter 'meteringUnitName' is not null or undefined
            assertParamExists('getMeteringUnitDateCountByTenantIdAndUnitNameAndDate', 'meteringUnitName', meteringUnitName)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getMeteringUnitDateCountByTenantIdAndUnitNameAndDate', 'date', date)
            const localVarPath = `/metering/tenants/{tenant_id}/units/{metering_unit_name}/date/{date}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"metering_unit_name"}}`, encodeURIComponent(String(meteringUnitName)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtain metering unit counts for a specified date/time period. 
         * @summary Obtain metering unit counts for a specified date/time period
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {number} [startTimestamp] Start Date-Time
         * @param {number} [endTimestamp] End Date-Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeteringUnitDateCountByTenantIdAndUnitNameAndDatePeriod: async (tenantId: string, meteringUnitName: string, startTimestamp?: number, endTimestamp?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getMeteringUnitDateCountByTenantIdAndUnitNameAndDatePeriod', 'tenantId', tenantId)
            // verify required parameter 'meteringUnitName' is not null or undefined
            assertParamExists('getMeteringUnitDateCountByTenantIdAndUnitNameAndDatePeriod', 'meteringUnitName', meteringUnitName)
            const localVarPath = `/metering/tenants/{tenant_id}/units/{metering_unit_name}/date-period`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"metering_unit_name"}}`, encodeURIComponent(String(meteringUnitName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startTimestamp !== undefined) {
                localVarQueryParameter['start_timestamp'] = startTimestamp;
            }

            if (endTimestamp !== undefined) {
                localVarQueryParameter['end_timestamp'] = endTimestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the metering unit count for the current day. 
         * @summary Get Metering Unit Count for the Current Day
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeteringUnitDateCountByTenantIdAndUnitNameToday: async (tenantId: string, meteringUnitName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getMeteringUnitDateCountByTenantIdAndUnitNameToday', 'tenantId', tenantId)
            // verify required parameter 'meteringUnitName' is not null or undefined
            assertParamExists('getMeteringUnitDateCountByTenantIdAndUnitNameToday', 'meteringUnitName', meteringUnitName)
            const localVarPath = `/metering/tenants/{tenant_id}/units/{metering_unit_name}/today`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"metering_unit_name"}}`, encodeURIComponent(String(meteringUnitName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the total metering unit count for the specified date. 
         * @summary Get All Metering Unit Counts for a Specified Date
         * @param {string} tenantId Tenant ID
         * @param {string} date Date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeteringUnitDateCountsByTenantIdAndDate: async (tenantId: string, date: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getMeteringUnitDateCountsByTenantIdAndDate', 'tenantId', tenantId)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getMeteringUnitDateCountsByTenantIdAndDate', 'date', date)
            const localVarPath = `/metering/tenants/{tenant_id}/units/date/{date}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the metering unit count for the specified month. 
         * @summary Get the Metering Unit Count for the Specified Month
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {string} month Month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeteringUnitMonthCountByTenantIdAndUnitNameAndMonth: async (tenantId: string, meteringUnitName: string, month: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getMeteringUnitMonthCountByTenantIdAndUnitNameAndMonth', 'tenantId', tenantId)
            // verify required parameter 'meteringUnitName' is not null or undefined
            assertParamExists('getMeteringUnitMonthCountByTenantIdAndUnitNameAndMonth', 'meteringUnitName', meteringUnitName)
            // verify required parameter 'month' is not null or undefined
            assertParamExists('getMeteringUnitMonthCountByTenantIdAndUnitNameAndMonth', 'month', month)
            const localVarPath = `/metering/tenants/{tenant_id}/units/{metering_unit_name}/month/{month}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"metering_unit_name"}}`, encodeURIComponent(String(meteringUnitName)))
                .replace(`{${"month"}}`, encodeURIComponent(String(month)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the metering unit count for the current month. 
         * @summary Get Metering Unit Count for the Current Month
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeteringUnitMonthCountByTenantIdAndUnitNameThisMonth: async (tenantId: string, meteringUnitName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getMeteringUnitMonthCountByTenantIdAndUnitNameThisMonth', 'tenantId', tenantId)
            // verify required parameter 'meteringUnitName' is not null or undefined
            assertParamExists('getMeteringUnitMonthCountByTenantIdAndUnitNameThisMonth', 'meteringUnitName', meteringUnitName)
            const localVarPath = `/metering/tenants/{tenant_id}/units/{metering_unit_name}/thismonth`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"metering_unit_name"}}`, encodeURIComponent(String(meteringUnitName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all metering unit counts for the specified month. 
         * @summary Get All Metering Unit Counts for the Specified Month
         * @param {string} tenantId Tenant ID
         * @param {string} month Month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeteringUnitMonthCountsByTenantIdAndMonth: async (tenantId: string, month: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getMeteringUnitMonthCountsByTenantIdAndMonth', 'tenantId', tenantId)
            // verify required parameter 'month' is not null or undefined
            assertParamExists('getMeteringUnitMonthCountsByTenantIdAndMonth', 'month', month)
            const localVarPath = `/metering/tenants/{tenant_id}/units/month/{month}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"month"}}`, encodeURIComponent(String(month)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all metering units. 
         * @summary Get all metering units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeteringUnits: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metering/units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update metering unit. 
         * @summary Update Metering Unit
         * @param {string} meteringUnitId Metering Unit ID
         * @param {MeteringUnitProps} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeteringUnitByID: async (meteringUnitId: string, body?: MeteringUnitProps, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'meteringUnitId' is not null or undefined
            assertParamExists('updateMeteringUnitByID', 'meteringUnitId', meteringUnitId)
            const localVarPath = `/metering/units/{metering_unit_id}`
                .replace(`{${"metering_unit_id"}}`, encodeURIComponent(String(meteringUnitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update metering unit count for the specified timestamp. 
         * @summary Update Metering Unit Count for Specified Timestamp
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {number} timestamp Timestamp
         * @param {UpdateMeteringUnitTimestampCountParam} [updateMeteringUnitTimestampCountParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeteringUnitTimestampCount: async (tenantId: string, meteringUnitName: string, timestamp: number, updateMeteringUnitTimestampCountParam?: UpdateMeteringUnitTimestampCountParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('updateMeteringUnitTimestampCount', 'tenantId', tenantId)
            // verify required parameter 'meteringUnitName' is not null or undefined
            assertParamExists('updateMeteringUnitTimestampCount', 'meteringUnitName', meteringUnitName)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('updateMeteringUnitTimestampCount', 'timestamp', timestamp)
            const localVarPath = `/metering/tenants/{tenant_id}/units/{metering_unit_name}/timestamp/{timestamp}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"metering_unit_name"}}`, encodeURIComponent(String(meteringUnitName)))
                .replace(`{${"timestamp"}}`, encodeURIComponent(String(timestamp)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMeteringUnitTimestampCountParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the metering unit count for the current time. 
         * @summary Update Metering Unit Count for Current Time
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {UpdateMeteringUnitTimestampCountNowParam} [updateMeteringUnitTimestampCountNowParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeteringUnitTimestampCountNow: async (tenantId: string, meteringUnitName: string, updateMeteringUnitTimestampCountNowParam?: UpdateMeteringUnitTimestampCountNowParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('updateMeteringUnitTimestampCountNow', 'tenantId', tenantId)
            // verify required parameter 'meteringUnitName' is not null or undefined
            assertParamExists('updateMeteringUnitTimestampCountNow', 'meteringUnitName', meteringUnitName)
            const localVarPath = `/metering/tenants/{tenant_id}/units/{metering_unit_name}/now`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"metering_unit_name"}}`, encodeURIComponent(String(meteringUnitName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMeteringUnitTimestampCountNowParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeteringApi - functional programming interface
 * @export
 */
export const MeteringApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeteringApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a metering unit. 
         * @summary Create Metering Unit
         * @param {MeteringUnitProps} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMeteringUnit(body?: MeteringUnitProps, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringUnit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMeteringUnit(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete metering unit. 
         * @summary Delete Metering Unit
         * @param {string} meteringUnitId Metering Unit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMeteringUnitByID(meteringUnitId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMeteringUnitByID(meteringUnitId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes metering unit count for the specified timestamp. 
         * @summary Delete Metering Unit Count for Specified Timestamp
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {number} timestamp Timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMeteringUnitTimestampCount(tenantId: string, meteringUnitName: string, timestamp: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMeteringUnitTimestampCount(tenantId, meteringUnitName, timestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the metering unit count for a specific date. 
         * @summary Get Metering Unit Count for Specific Date
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {string} date Date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMeteringUnitDateCountByTenantIdAndUnitNameAndDate(tenantId: string, meteringUnitName: string, date: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringUnitDateCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMeteringUnitDateCountByTenantIdAndUnitNameAndDate(tenantId, meteringUnitName, date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Obtain metering unit counts for a specified date/time period. 
         * @summary Obtain metering unit counts for a specified date/time period
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {number} [startTimestamp] Start Date-Time
         * @param {number} [endTimestamp] End Date-Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMeteringUnitDateCountByTenantIdAndUnitNameAndDatePeriod(tenantId: string, meteringUnitName: string, startTimestamp?: number, endTimestamp?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringUnitDatePeriodCounts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMeteringUnitDateCountByTenantIdAndUnitNameAndDatePeriod(tenantId, meteringUnitName, startTimestamp, endTimestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the metering unit count for the current day. 
         * @summary Get Metering Unit Count for the Current Day
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMeteringUnitDateCountByTenantIdAndUnitNameToday(tenantId: string, meteringUnitName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringUnitDateCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMeteringUnitDateCountByTenantIdAndUnitNameToday(tenantId, meteringUnitName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the total metering unit count for the specified date. 
         * @summary Get All Metering Unit Counts for a Specified Date
         * @param {string} tenantId Tenant ID
         * @param {string} date Date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMeteringUnitDateCountsByTenantIdAndDate(tenantId: string, date: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringUnitDateCounts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMeteringUnitDateCountsByTenantIdAndDate(tenantId, date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the metering unit count for the specified month. 
         * @summary Get the Metering Unit Count for the Specified Month
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {string} month Month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMeteringUnitMonthCountByTenantIdAndUnitNameAndMonth(tenantId: string, meteringUnitName: string, month: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringUnitMonthCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMeteringUnitMonthCountByTenantIdAndUnitNameAndMonth(tenantId, meteringUnitName, month, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the metering unit count for the current month. 
         * @summary Get Metering Unit Count for the Current Month
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMeteringUnitMonthCountByTenantIdAndUnitNameThisMonth(tenantId: string, meteringUnitName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringUnitMonthCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMeteringUnitMonthCountByTenantIdAndUnitNameThisMonth(tenantId, meteringUnitName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets all metering unit counts for the specified month. 
         * @summary Get All Metering Unit Counts for the Specified Month
         * @param {string} tenantId Tenant ID
         * @param {string} month Month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMeteringUnitMonthCountsByTenantIdAndMonth(tenantId: string, month: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringUnitMonthCounts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMeteringUnitMonthCountsByTenantIdAndMonth(tenantId, month, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all metering units. 
         * @summary Get all metering units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMeteringUnits(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringUnits>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMeteringUnits(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update metering unit. 
         * @summary Update Metering Unit
         * @param {string} meteringUnitId Metering Unit ID
         * @param {MeteringUnitProps} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMeteringUnitByID(meteringUnitId: string, body?: MeteringUnitProps, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMeteringUnitByID(meteringUnitId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update metering unit count for the specified timestamp. 
         * @summary Update Metering Unit Count for Specified Timestamp
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {number} timestamp Timestamp
         * @param {UpdateMeteringUnitTimestampCountParam} [updateMeteringUnitTimestampCountParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMeteringUnitTimestampCount(tenantId: string, meteringUnitName: string, timestamp: number, updateMeteringUnitTimestampCountParam?: UpdateMeteringUnitTimestampCountParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringUnitTimestampCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMeteringUnitTimestampCount(tenantId, meteringUnitName, timestamp, updateMeteringUnitTimestampCountParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the metering unit count for the current time. 
         * @summary Update Metering Unit Count for Current Time
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {UpdateMeteringUnitTimestampCountNowParam} [updateMeteringUnitTimestampCountNowParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMeteringUnitTimestampCountNow(tenantId: string, meteringUnitName: string, updateMeteringUnitTimestampCountNowParam?: UpdateMeteringUnitTimestampCountNowParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringUnitTimestampCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMeteringUnitTimestampCountNow(tenantId, meteringUnitName, updateMeteringUnitTimestampCountNowParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MeteringApi - factory interface
 * @export
 */
export const MeteringApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeteringApiFp(configuration)
    return {
        /**
         * Create a metering unit. 
         * @summary Create Metering Unit
         * @param {MeteringUnitProps} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMeteringUnit(body?: MeteringUnitProps, options?: any): AxiosPromise<MeteringUnit> {
            return localVarFp.createMeteringUnit(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete metering unit. 
         * @summary Delete Metering Unit
         * @param {string} meteringUnitId Metering Unit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeteringUnitByID(meteringUnitId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMeteringUnitByID(meteringUnitId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes metering unit count for the specified timestamp. 
         * @summary Delete Metering Unit Count for Specified Timestamp
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {number} timestamp Timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeteringUnitTimestampCount(tenantId: string, meteringUnitName: string, timestamp: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMeteringUnitTimestampCount(tenantId, meteringUnitName, timestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the metering unit count for a specific date. 
         * @summary Get Metering Unit Count for Specific Date
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {string} date Date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeteringUnitDateCountByTenantIdAndUnitNameAndDate(tenantId: string, meteringUnitName: string, date: string, options?: any): AxiosPromise<MeteringUnitDateCount> {
            return localVarFp.getMeteringUnitDateCountByTenantIdAndUnitNameAndDate(tenantId, meteringUnitName, date, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtain metering unit counts for a specified date/time period. 
         * @summary Obtain metering unit counts for a specified date/time period
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {number} [startTimestamp] Start Date-Time
         * @param {number} [endTimestamp] End Date-Time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeteringUnitDateCountByTenantIdAndUnitNameAndDatePeriod(tenantId: string, meteringUnitName: string, startTimestamp?: number, endTimestamp?: number, options?: any): AxiosPromise<MeteringUnitDatePeriodCounts> {
            return localVarFp.getMeteringUnitDateCountByTenantIdAndUnitNameAndDatePeriod(tenantId, meteringUnitName, startTimestamp, endTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the metering unit count for the current day. 
         * @summary Get Metering Unit Count for the Current Day
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeteringUnitDateCountByTenantIdAndUnitNameToday(tenantId: string, meteringUnitName: string, options?: any): AxiosPromise<MeteringUnitDateCount> {
            return localVarFp.getMeteringUnitDateCountByTenantIdAndUnitNameToday(tenantId, meteringUnitName, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the total metering unit count for the specified date. 
         * @summary Get All Metering Unit Counts for a Specified Date
         * @param {string} tenantId Tenant ID
         * @param {string} date Date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeteringUnitDateCountsByTenantIdAndDate(tenantId: string, date: string, options?: any): AxiosPromise<MeteringUnitDateCounts> {
            return localVarFp.getMeteringUnitDateCountsByTenantIdAndDate(tenantId, date, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the metering unit count for the specified month. 
         * @summary Get the Metering Unit Count for the Specified Month
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {string} month Month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeteringUnitMonthCountByTenantIdAndUnitNameAndMonth(tenantId: string, meteringUnitName: string, month: string, options?: any): AxiosPromise<MeteringUnitMonthCount> {
            return localVarFp.getMeteringUnitMonthCountByTenantIdAndUnitNameAndMonth(tenantId, meteringUnitName, month, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the metering unit count for the current month. 
         * @summary Get Metering Unit Count for the Current Month
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeteringUnitMonthCountByTenantIdAndUnitNameThisMonth(tenantId: string, meteringUnitName: string, options?: any): AxiosPromise<MeteringUnitMonthCount> {
            return localVarFp.getMeteringUnitMonthCountByTenantIdAndUnitNameThisMonth(tenantId, meteringUnitName, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all metering unit counts for the specified month. 
         * @summary Get All Metering Unit Counts for the Specified Month
         * @param {string} tenantId Tenant ID
         * @param {string} month Month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeteringUnitMonthCountsByTenantIdAndMonth(tenantId: string, month: string, options?: any): AxiosPromise<MeteringUnitMonthCounts> {
            return localVarFp.getMeteringUnitMonthCountsByTenantIdAndMonth(tenantId, month, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all metering units. 
         * @summary Get all metering units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeteringUnits(options?: any): AxiosPromise<MeteringUnits> {
            return localVarFp.getMeteringUnits(options).then((request) => request(axios, basePath));
        },
        /**
         * Update metering unit. 
         * @summary Update Metering Unit
         * @param {string} meteringUnitId Metering Unit ID
         * @param {MeteringUnitProps} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeteringUnitByID(meteringUnitId: string, body?: MeteringUnitProps, options?: any): AxiosPromise<void> {
            return localVarFp.updateMeteringUnitByID(meteringUnitId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update metering unit count for the specified timestamp. 
         * @summary Update Metering Unit Count for Specified Timestamp
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {number} timestamp Timestamp
         * @param {UpdateMeteringUnitTimestampCountParam} [updateMeteringUnitTimestampCountParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeteringUnitTimestampCount(tenantId: string, meteringUnitName: string, timestamp: number, updateMeteringUnitTimestampCountParam?: UpdateMeteringUnitTimestampCountParam, options?: any): AxiosPromise<MeteringUnitTimestampCount> {
            return localVarFp.updateMeteringUnitTimestampCount(tenantId, meteringUnitName, timestamp, updateMeteringUnitTimestampCountParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the metering unit count for the current time. 
         * @summary Update Metering Unit Count for Current Time
         * @param {string} tenantId Tenant ID
         * @param {string} meteringUnitName Metering Unit Name
         * @param {UpdateMeteringUnitTimestampCountNowParam} [updateMeteringUnitTimestampCountNowParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeteringUnitTimestampCountNow(tenantId: string, meteringUnitName: string, updateMeteringUnitTimestampCountNowParam?: UpdateMeteringUnitTimestampCountNowParam, options?: any): AxiosPromise<MeteringUnitTimestampCount> {
            return localVarFp.updateMeteringUnitTimestampCountNow(tenantId, meteringUnitName, updateMeteringUnitTimestampCountNowParam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeteringApi - object-oriented interface
 * @export
 * @class MeteringApi
 * @extends {BaseAPI}
 */
export class MeteringApi extends BaseAPI {
    /**
     * Create a metering unit. 
     * @summary Create Metering Unit
     * @param {MeteringUnitProps} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public createMeteringUnit(body?: MeteringUnitProps, options?: AxiosRequestConfig) {
        return MeteringApiFp(this.configuration).createMeteringUnit(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete metering unit. 
     * @summary Delete Metering Unit
     * @param {string} meteringUnitId Metering Unit ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public deleteMeteringUnitByID(meteringUnitId: string, options?: AxiosRequestConfig) {
        return MeteringApiFp(this.configuration).deleteMeteringUnitByID(meteringUnitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes metering unit count for the specified timestamp. 
     * @summary Delete Metering Unit Count for Specified Timestamp
     * @param {string} tenantId Tenant ID
     * @param {string} meteringUnitName Metering Unit Name
     * @param {number} timestamp Timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public deleteMeteringUnitTimestampCount(tenantId: string, meteringUnitName: string, timestamp: number, options?: AxiosRequestConfig) {
        return MeteringApiFp(this.configuration).deleteMeteringUnitTimestampCount(tenantId, meteringUnitName, timestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the metering unit count for a specific date. 
     * @summary Get Metering Unit Count for Specific Date
     * @param {string} tenantId Tenant ID
     * @param {string} meteringUnitName Metering Unit Name
     * @param {string} date Date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public getMeteringUnitDateCountByTenantIdAndUnitNameAndDate(tenantId: string, meteringUnitName: string, date: string, options?: AxiosRequestConfig) {
        return MeteringApiFp(this.configuration).getMeteringUnitDateCountByTenantIdAndUnitNameAndDate(tenantId, meteringUnitName, date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtain metering unit counts for a specified date/time period. 
     * @summary Obtain metering unit counts for a specified date/time period
     * @param {string} tenantId Tenant ID
     * @param {string} meteringUnitName Metering Unit Name
     * @param {number} [startTimestamp] Start Date-Time
     * @param {number} [endTimestamp] End Date-Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public getMeteringUnitDateCountByTenantIdAndUnitNameAndDatePeriod(tenantId: string, meteringUnitName: string, startTimestamp?: number, endTimestamp?: number, options?: AxiosRequestConfig) {
        return MeteringApiFp(this.configuration).getMeteringUnitDateCountByTenantIdAndUnitNameAndDatePeriod(tenantId, meteringUnitName, startTimestamp, endTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the metering unit count for the current day. 
     * @summary Get Metering Unit Count for the Current Day
     * @param {string} tenantId Tenant ID
     * @param {string} meteringUnitName Metering Unit Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public getMeteringUnitDateCountByTenantIdAndUnitNameToday(tenantId: string, meteringUnitName: string, options?: AxiosRequestConfig) {
        return MeteringApiFp(this.configuration).getMeteringUnitDateCountByTenantIdAndUnitNameToday(tenantId, meteringUnitName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the total metering unit count for the specified date. 
     * @summary Get All Metering Unit Counts for a Specified Date
     * @param {string} tenantId Tenant ID
     * @param {string} date Date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public getMeteringUnitDateCountsByTenantIdAndDate(tenantId: string, date: string, options?: AxiosRequestConfig) {
        return MeteringApiFp(this.configuration).getMeteringUnitDateCountsByTenantIdAndDate(tenantId, date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the metering unit count for the specified month. 
     * @summary Get the Metering Unit Count for the Specified Month
     * @param {string} tenantId Tenant ID
     * @param {string} meteringUnitName Metering Unit Name
     * @param {string} month Month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public getMeteringUnitMonthCountByTenantIdAndUnitNameAndMonth(tenantId: string, meteringUnitName: string, month: string, options?: AxiosRequestConfig) {
        return MeteringApiFp(this.configuration).getMeteringUnitMonthCountByTenantIdAndUnitNameAndMonth(tenantId, meteringUnitName, month, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the metering unit count for the current month. 
     * @summary Get Metering Unit Count for the Current Month
     * @param {string} tenantId Tenant ID
     * @param {string} meteringUnitName Metering Unit Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public getMeteringUnitMonthCountByTenantIdAndUnitNameThisMonth(tenantId: string, meteringUnitName: string, options?: AxiosRequestConfig) {
        return MeteringApiFp(this.configuration).getMeteringUnitMonthCountByTenantIdAndUnitNameThisMonth(tenantId, meteringUnitName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all metering unit counts for the specified month. 
     * @summary Get All Metering Unit Counts for the Specified Month
     * @param {string} tenantId Tenant ID
     * @param {string} month Month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public getMeteringUnitMonthCountsByTenantIdAndMonth(tenantId: string, month: string, options?: AxiosRequestConfig) {
        return MeteringApiFp(this.configuration).getMeteringUnitMonthCountsByTenantIdAndMonth(tenantId, month, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all metering units. 
     * @summary Get all metering units
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public getMeteringUnits(options?: AxiosRequestConfig) {
        return MeteringApiFp(this.configuration).getMeteringUnits(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update metering unit. 
     * @summary Update Metering Unit
     * @param {string} meteringUnitId Metering Unit ID
     * @param {MeteringUnitProps} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public updateMeteringUnitByID(meteringUnitId: string, body?: MeteringUnitProps, options?: AxiosRequestConfig) {
        return MeteringApiFp(this.configuration).updateMeteringUnitByID(meteringUnitId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update metering unit count for the specified timestamp. 
     * @summary Update Metering Unit Count for Specified Timestamp
     * @param {string} tenantId Tenant ID
     * @param {string} meteringUnitName Metering Unit Name
     * @param {number} timestamp Timestamp
     * @param {UpdateMeteringUnitTimestampCountParam} [updateMeteringUnitTimestampCountParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public updateMeteringUnitTimestampCount(tenantId: string, meteringUnitName: string, timestamp: number, updateMeteringUnitTimestampCountParam?: UpdateMeteringUnitTimestampCountParam, options?: AxiosRequestConfig) {
        return MeteringApiFp(this.configuration).updateMeteringUnitTimestampCount(tenantId, meteringUnitName, timestamp, updateMeteringUnitTimestampCountParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the metering unit count for the current time. 
     * @summary Update Metering Unit Count for Current Time
     * @param {string} tenantId Tenant ID
     * @param {string} meteringUnitName Metering Unit Name
     * @param {UpdateMeteringUnitTimestampCountNowParam} [updateMeteringUnitTimestampCountNowParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public updateMeteringUnitTimestampCountNow(tenantId: string, meteringUnitName: string, updateMeteringUnitTimestampCountNowParam?: UpdateMeteringUnitTimestampCountNowParam, options?: AxiosRequestConfig) {
        return MeteringApiFp(this.configuration).updateMeteringUnitTimestampCountNow(tenantId, meteringUnitName, updateMeteringUnitTimestampCountNowParam, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PricingMenusApi - axios parameter creator
 * @export
 */
export const PricingMenusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a pricing feature menu. 
         * @summary Create a Pricing Feature Menu
         * @param {SavePricingMenuParam} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPricingMenu: async (body?: SavePricingMenuParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/menus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete pricing feature menu. 
         * @summary Delete Pricing Feature Menu
         * @param {string} menuId Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePricingMenu: async (menuId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'menuId' is not null or undefined
            assertParamExists('deletePricingMenu', 'menuId', menuId)
            const localVarPath = `/menus/{menu_id}`
                .replace(`{${"menu_id"}}`, encodeURIComponent(String(menuId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a pricing feature menu. 
         * @summary Get Pricing Feature Menu
         * @param {string} menuId Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingMenu: async (menuId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'menuId' is not null or undefined
            assertParamExists('getPricingMenu', 'menuId', menuId)
            const localVarPath = `/menus/{menu_id}`
                .replace(`{${"menu_id"}}`, encodeURIComponent(String(menuId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the feature menu list. Multiple measurement units are grouped together and defined as one feature menu. Multiple feature menus defined here are combined into one billing plan. 
         * @summary Get Pricing Feature Menus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingMenus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/menus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update pricing feature menu. 
         * @summary Update Pricing Feature Menu
         * @param {string} menuId Menu ID
         * @param {SavePricingMenuParam} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricingMenu: async (menuId: string, body?: SavePricingMenuParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'menuId' is not null or undefined
            assertParamExists('updatePricingMenu', 'menuId', menuId)
            const localVarPath = `/menus/{menu_id}`
                .replace(`{${"menu_id"}}`, encodeURIComponent(String(menuId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PricingMenusApi - functional programming interface
 * @export
 */
export const PricingMenusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PricingMenusApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a pricing feature menu. 
         * @summary Create a Pricing Feature Menu
         * @param {SavePricingMenuParam} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPricingMenu(body?: SavePricingMenuParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricingMenu>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPricingMenu(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete pricing feature menu. 
         * @summary Delete Pricing Feature Menu
         * @param {string} menuId Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePricingMenu(menuId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePricingMenu(menuId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a pricing feature menu. 
         * @summary Get Pricing Feature Menu
         * @param {string} menuId Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricingMenu(menuId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricingMenu>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricingMenu(menuId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the feature menu list. Multiple measurement units are grouped together and defined as one feature menu. Multiple feature menus defined here are combined into one billing plan. 
         * @summary Get Pricing Feature Menus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricingMenus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricingMenus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricingMenus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update pricing feature menu. 
         * @summary Update Pricing Feature Menu
         * @param {string} menuId Menu ID
         * @param {SavePricingMenuParam} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePricingMenu(menuId: string, body?: SavePricingMenuParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePricingMenu(menuId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PricingMenusApi - factory interface
 * @export
 */
export const PricingMenusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PricingMenusApiFp(configuration)
    return {
        /**
         * Create a pricing feature menu. 
         * @summary Create a Pricing Feature Menu
         * @param {SavePricingMenuParam} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPricingMenu(body?: SavePricingMenuParam, options?: any): AxiosPromise<PricingMenu> {
            return localVarFp.createPricingMenu(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete pricing feature menu. 
         * @summary Delete Pricing Feature Menu
         * @param {string} menuId Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePricingMenu(menuId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePricingMenu(menuId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a pricing feature menu. 
         * @summary Get Pricing Feature Menu
         * @param {string} menuId Menu ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingMenu(menuId: string, options?: any): AxiosPromise<PricingMenu> {
            return localVarFp.getPricingMenu(menuId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the feature menu list. Multiple measurement units are grouped together and defined as one feature menu. Multiple feature menus defined here are combined into one billing plan. 
         * @summary Get Pricing Feature Menus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingMenus(options?: any): AxiosPromise<PricingMenus> {
            return localVarFp.getPricingMenus(options).then((request) => request(axios, basePath));
        },
        /**
         * Update pricing feature menu. 
         * @summary Update Pricing Feature Menu
         * @param {string} menuId Menu ID
         * @param {SavePricingMenuParam} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricingMenu(menuId: string, body?: SavePricingMenuParam, options?: any): AxiosPromise<void> {
            return localVarFp.updatePricingMenu(menuId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PricingMenusApi - object-oriented interface
 * @export
 * @class PricingMenusApi
 * @extends {BaseAPI}
 */
export class PricingMenusApi extends BaseAPI {
    /**
     * Create a pricing feature menu. 
     * @summary Create a Pricing Feature Menu
     * @param {SavePricingMenuParam} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingMenusApi
     */
    public createPricingMenu(body?: SavePricingMenuParam, options?: AxiosRequestConfig) {
        return PricingMenusApiFp(this.configuration).createPricingMenu(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete pricing feature menu. 
     * @summary Delete Pricing Feature Menu
     * @param {string} menuId Menu ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingMenusApi
     */
    public deletePricingMenu(menuId: string, options?: AxiosRequestConfig) {
        return PricingMenusApiFp(this.configuration).deletePricingMenu(menuId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a pricing feature menu. 
     * @summary Get Pricing Feature Menu
     * @param {string} menuId Menu ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingMenusApi
     */
    public getPricingMenu(menuId: string, options?: AxiosRequestConfig) {
        return PricingMenusApiFp(this.configuration).getPricingMenu(menuId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the feature menu list. Multiple measurement units are grouped together and defined as one feature menu. Multiple feature menus defined here are combined into one billing plan. 
     * @summary Get Pricing Feature Menus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingMenusApi
     */
    public getPricingMenus(options?: AxiosRequestConfig) {
        return PricingMenusApiFp(this.configuration).getPricingMenus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update pricing feature menu. 
     * @summary Update Pricing Feature Menu
     * @param {string} menuId Menu ID
     * @param {SavePricingMenuParam} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingMenusApi
     */
    public updatePricingMenu(menuId: string, body?: SavePricingMenuParam, options?: AxiosRequestConfig) {
        return PricingMenusApiFp(this.configuration).updatePricingMenu(menuId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PricingPlansApi - axios parameter creator
 * @export
 */
export const PricingPlansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a pricing plan. 
         * @summary Create Pricing Plan
         * @param {SavePricingPlanParam} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPricingPlan: async (body?: SavePricingPlanParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unconditionally remove all rate plans, menus, units, meters and tax rates. 
         * @summary Delete all Plans, Menus, Units, Meters and Tax Rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllPlansAndMenusAndUnitsAndMetersAndTaxRates: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/plans-initialization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a pricing plan. 
         * @summary Delete Pricing Plan
         * @param {string} planId Pricing Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePricingPlan: async (planId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('deletePricingPlan', 'planId', planId)
            const localVarPath = `/plans/{plan_id}`
                .replace(`{${"plan_id"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete product data from Stripe. 
         * @summary Delete Product Data from Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStripePlan: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a pricing plan. 
         * @summary Get Pricing Plan
         * @param {string} planId Pricing Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingPlan: async (planId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('getPricingPlan', 'planId', planId)
            const localVarPath = `/plans/{plan_id}`
                .replace(`{${"plan_id"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get pricing plans. Multiple feature menus are grouped together and defined as one pricing plan. Each tenant can choose a pricing plan defined here. If you have a specific tenant-specific rate (private pricing), create and connect the pricing plan specifically for that tenant. 
         * @summary Get Pricing Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingPlans: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Connect information to Stripe. 
         * @summary Connect to Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPlanToStripe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a pricing plan. 
         * @summary Update Pricing Plan
         * @param {string} planId Pricing Plan ID
         * @param {SavePricingPlanParam} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricingPlan: async (planId: string, body?: SavePricingPlanParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('updatePricingPlan', 'planId', planId)
            const localVarPath = `/plans/{plan_id}`
                .replace(`{${"plan_id"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update price plan and feature menu/pricing unit to used. 
         * @summary Update Used Flag
         * @param {UpdatePricingPlansUsedParam} [updatePricingPlansUsedParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricingPlansUsed: async (updatePricingPlansUsedParam?: UpdatePricingPlansUsedParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/plans/used`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePricingPlansUsedParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PricingPlansApi - functional programming interface
 * @export
 */
export const PricingPlansApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PricingPlansApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a pricing plan. 
         * @summary Create Pricing Plan
         * @param {SavePricingPlanParam} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPricingPlan(body?: SavePricingPlanParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricingPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPricingPlan(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unconditionally remove all rate plans, menus, units, meters and tax rates. 
         * @summary Delete all Plans, Menus, Units, Meters and Tax Rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllPlansAndMenusAndUnitsAndMetersAndTaxRates(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllPlansAndMenusAndUnitsAndMetersAndTaxRates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a pricing plan. 
         * @summary Delete Pricing Plan
         * @param {string} planId Pricing Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePricingPlan(planId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePricingPlan(planId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete product data from Stripe. 
         * @summary Delete Product Data from Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStripePlan(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStripePlan(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a pricing plan. 
         * @summary Get Pricing Plan
         * @param {string} planId Pricing Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricingPlan(planId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricingPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricingPlan(planId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get pricing plans. Multiple feature menus are grouped together and defined as one pricing plan. Each tenant can choose a pricing plan defined here. If you have a specific tenant-specific rate (private pricing), create and connect the pricing plan specifically for that tenant. 
         * @summary Get Pricing Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricingPlans(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricingPlans>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricingPlans(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Connect information to Stripe. 
         * @summary Connect to Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkPlanToStripe(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkPlanToStripe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a pricing plan. 
         * @summary Update Pricing Plan
         * @param {string} planId Pricing Plan ID
         * @param {SavePricingPlanParam} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePricingPlan(planId: string, body?: SavePricingPlanParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePricingPlan(planId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update price plan and feature menu/pricing unit to used. 
         * @summary Update Used Flag
         * @param {UpdatePricingPlansUsedParam} [updatePricingPlansUsedParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePricingPlansUsed(updatePricingPlansUsedParam?: UpdatePricingPlansUsedParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePricingPlansUsed(updatePricingPlansUsedParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PricingPlansApi - factory interface
 * @export
 */
export const PricingPlansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PricingPlansApiFp(configuration)
    return {
        /**
         * Create a pricing plan. 
         * @summary Create Pricing Plan
         * @param {SavePricingPlanParam} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPricingPlan(body?: SavePricingPlanParam, options?: any): AxiosPromise<PricingPlan> {
            return localVarFp.createPricingPlan(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Unconditionally remove all rate plans, menus, units, meters and tax rates. 
         * @summary Delete all Plans, Menus, Units, Meters and Tax Rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllPlansAndMenusAndUnitsAndMetersAndTaxRates(options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllPlansAndMenusAndUnitsAndMetersAndTaxRates(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a pricing plan. 
         * @summary Delete Pricing Plan
         * @param {string} planId Pricing Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePricingPlan(planId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePricingPlan(planId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete product data from Stripe. 
         * @summary Delete Product Data from Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStripePlan(options?: any): AxiosPromise<void> {
            return localVarFp.deleteStripePlan(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a pricing plan. 
         * @summary Get Pricing Plan
         * @param {string} planId Pricing Plan ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingPlan(planId: string, options?: any): AxiosPromise<PricingPlan> {
            return localVarFp.getPricingPlan(planId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get pricing plans. Multiple feature menus are grouped together and defined as one pricing plan. Each tenant can choose a pricing plan defined here. If you have a specific tenant-specific rate (private pricing), create and connect the pricing plan specifically for that tenant. 
         * @summary Get Pricing Plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingPlans(options?: any): AxiosPromise<PricingPlans> {
            return localVarFp.getPricingPlans(options).then((request) => request(axios, basePath));
        },
        /**
         * Connect information to Stripe. 
         * @summary Connect to Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkPlanToStripe(options?: any): AxiosPromise<void> {
            return localVarFp.linkPlanToStripe(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a pricing plan. 
         * @summary Update Pricing Plan
         * @param {string} planId Pricing Plan ID
         * @param {SavePricingPlanParam} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricingPlan(planId: string, body?: SavePricingPlanParam, options?: any): AxiosPromise<void> {
            return localVarFp.updatePricingPlan(planId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update price plan and feature menu/pricing unit to used. 
         * @summary Update Used Flag
         * @param {UpdatePricingPlansUsedParam} [updatePricingPlansUsedParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricingPlansUsed(updatePricingPlansUsedParam?: UpdatePricingPlansUsedParam, options?: any): AxiosPromise<void> {
            return localVarFp.updatePricingPlansUsed(updatePricingPlansUsedParam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PricingPlansApi - object-oriented interface
 * @export
 * @class PricingPlansApi
 * @extends {BaseAPI}
 */
export class PricingPlansApi extends BaseAPI {
    /**
     * Create a pricing plan. 
     * @summary Create Pricing Plan
     * @param {SavePricingPlanParam} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingPlansApi
     */
    public createPricingPlan(body?: SavePricingPlanParam, options?: AxiosRequestConfig) {
        return PricingPlansApiFp(this.configuration).createPricingPlan(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unconditionally remove all rate plans, menus, units, meters and tax rates. 
     * @summary Delete all Plans, Menus, Units, Meters and Tax Rates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingPlansApi
     */
    public deleteAllPlansAndMenusAndUnitsAndMetersAndTaxRates(options?: AxiosRequestConfig) {
        return PricingPlansApiFp(this.configuration).deleteAllPlansAndMenusAndUnitsAndMetersAndTaxRates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a pricing plan. 
     * @summary Delete Pricing Plan
     * @param {string} planId Pricing Plan ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingPlansApi
     */
    public deletePricingPlan(planId: string, options?: AxiosRequestConfig) {
        return PricingPlansApiFp(this.configuration).deletePricingPlan(planId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete product data from Stripe. 
     * @summary Delete Product Data from Stripe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingPlansApi
     */
    public deleteStripePlan(options?: AxiosRequestConfig) {
        return PricingPlansApiFp(this.configuration).deleteStripePlan(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a pricing plan. 
     * @summary Get Pricing Plan
     * @param {string} planId Pricing Plan ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingPlansApi
     */
    public getPricingPlan(planId: string, options?: AxiosRequestConfig) {
        return PricingPlansApiFp(this.configuration).getPricingPlan(planId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get pricing plans. Multiple feature menus are grouped together and defined as one pricing plan. Each tenant can choose a pricing plan defined here. If you have a specific tenant-specific rate (private pricing), create and connect the pricing plan specifically for that tenant. 
     * @summary Get Pricing Plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingPlansApi
     */
    public getPricingPlans(options?: AxiosRequestConfig) {
        return PricingPlansApiFp(this.configuration).getPricingPlans(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Connect information to Stripe. 
     * @summary Connect to Stripe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingPlansApi
     */
    public linkPlanToStripe(options?: AxiosRequestConfig) {
        return PricingPlansApiFp(this.configuration).linkPlanToStripe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a pricing plan. 
     * @summary Update Pricing Plan
     * @param {string} planId Pricing Plan ID
     * @param {SavePricingPlanParam} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingPlansApi
     */
    public updatePricingPlan(planId: string, body?: SavePricingPlanParam, options?: AxiosRequestConfig) {
        return PricingPlansApiFp(this.configuration).updatePricingPlan(planId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update price plan and feature menu/pricing unit to used. 
     * @summary Update Used Flag
     * @param {UpdatePricingPlansUsedParam} [updatePricingPlansUsedParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingPlansApi
     */
    public updatePricingPlansUsed(updatePricingPlansUsedParam?: UpdatePricingPlansUsedParam, options?: AxiosRequestConfig) {
        return PricingPlansApiFp(this.configuration).updatePricingPlansUsed(updatePricingPlansUsedParam, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PricingUnitsApi - axios parameter creator
 * @export
 */
export const PricingUnitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a pricing unit. 
         * @summary Create Pricing Unit
         * @param {PricingUnitForSave} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPricingUnit: async (body?: PricingUnitForSave, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a pricing unit. 
         * @summary Delete Pricing Unit
         * @param {string} pricingUnitId Unit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePricingUnit: async (pricingUnitId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricingUnitId' is not null or undefined
            assertParamExists('deletePricingUnit', 'pricingUnitId', pricingUnitId)
            const localVarPath = `/units/{pricing_unit_id}`
                .replace(`{${"pricing_unit_id"}}`, encodeURIComponent(String(pricingUnitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a pricing unit. 
         * @summary Get Pricing Unit
         * @param {string} pricingUnitId Unit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingUnit: async (pricingUnitId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricingUnitId' is not null or undefined
            assertParamExists('getPricingUnit', 'pricingUnitId', pricingUnitId)
            const localVarPath = `/units/{pricing_unit_id}`
                .replace(`{${"pricing_unit_id"}}`, encodeURIComponent(String(pricingUnitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the smallest unit of measure on which the charges are based. \"Fixed Unit\" (type=fixed) is a unit of a monthly fixed charge such as a basic charge, \"Usage Unit\" (type=usage) is a unit in which a charge is generated per unit such as billing for the number of users, \"Tiered Unit\" (type=tiered) is a fixed charge unit for each tier of usage, such as the tiered packet charge for mobile phones, \"Tiered Usage Unit\" (type=tiered_usage) is a unit where the charge per unit changes according to the usage amount, such as a volume discount. 
         * @summary Get Pricing Units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingUnits: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update pricing unit. 
         * @summary Update Pricing Unit
         * @param {string} pricingUnitId Unit ID
         * @param {PricingUnitForSave} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricingUnit: async (pricingUnitId: string, body?: PricingUnitForSave, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pricingUnitId' is not null or undefined
            assertParamExists('updatePricingUnit', 'pricingUnitId', pricingUnitId)
            const localVarPath = `/units/{pricing_unit_id}`
                .replace(`{${"pricing_unit_id"}}`, encodeURIComponent(String(pricingUnitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PricingUnitsApi - functional programming interface
 * @export
 */
export const PricingUnitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PricingUnitsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a pricing unit. 
         * @summary Create Pricing Unit
         * @param {PricingUnitForSave} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPricingUnit(body?: PricingUnitForSave, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricingUnit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPricingUnit(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a pricing unit. 
         * @summary Delete Pricing Unit
         * @param {string} pricingUnitId Unit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePricingUnit(pricingUnitId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePricingUnit(pricingUnitId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a pricing unit. 
         * @summary Get Pricing Unit
         * @param {string} pricingUnitId Unit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricingUnit(pricingUnitId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricingUnit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricingUnit(pricingUnitId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the smallest unit of measure on which the charges are based. \"Fixed Unit\" (type=fixed) is a unit of a monthly fixed charge such as a basic charge, \"Usage Unit\" (type=usage) is a unit in which a charge is generated per unit such as billing for the number of users, \"Tiered Unit\" (type=tiered) is a fixed charge unit for each tier of usage, such as the tiered packet charge for mobile phones, \"Tiered Usage Unit\" (type=tiered_usage) is a unit where the charge per unit changes according to the usage amount, such as a volume discount. 
         * @summary Get Pricing Units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPricingUnits(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PricingUnits>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPricingUnits(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update pricing unit. 
         * @summary Update Pricing Unit
         * @param {string} pricingUnitId Unit ID
         * @param {PricingUnitForSave} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePricingUnit(pricingUnitId: string, body?: PricingUnitForSave, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePricingUnit(pricingUnitId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PricingUnitsApi - factory interface
 * @export
 */
export const PricingUnitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PricingUnitsApiFp(configuration)
    return {
        /**
         * Create a pricing unit. 
         * @summary Create Pricing Unit
         * @param {PricingUnitForSave} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPricingUnit(body?: PricingUnitForSave, options?: any): AxiosPromise<PricingUnit> {
            return localVarFp.createPricingUnit(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a pricing unit. 
         * @summary Delete Pricing Unit
         * @param {string} pricingUnitId Unit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePricingUnit(pricingUnitId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePricingUnit(pricingUnitId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a pricing unit. 
         * @summary Get Pricing Unit
         * @param {string} pricingUnitId Unit ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingUnit(pricingUnitId: string, options?: any): AxiosPromise<PricingUnit> {
            return localVarFp.getPricingUnit(pricingUnitId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the smallest unit of measure on which the charges are based. \"Fixed Unit\" (type=fixed) is a unit of a monthly fixed charge such as a basic charge, \"Usage Unit\" (type=usage) is a unit in which a charge is generated per unit such as billing for the number of users, \"Tiered Unit\" (type=tiered) is a fixed charge unit for each tier of usage, such as the tiered packet charge for mobile phones, \"Tiered Usage Unit\" (type=tiered_usage) is a unit where the charge per unit changes according to the usage amount, such as a volume discount. 
         * @summary Get Pricing Units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPricingUnits(options?: any): AxiosPromise<PricingUnits> {
            return localVarFp.getPricingUnits(options).then((request) => request(axios, basePath));
        },
        /**
         * Update pricing unit. 
         * @summary Update Pricing Unit
         * @param {string} pricingUnitId Unit ID
         * @param {PricingUnitForSave} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePricingUnit(pricingUnitId: string, body?: PricingUnitForSave, options?: any): AxiosPromise<void> {
            return localVarFp.updatePricingUnit(pricingUnitId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PricingUnitsApi - object-oriented interface
 * @export
 * @class PricingUnitsApi
 * @extends {BaseAPI}
 */
export class PricingUnitsApi extends BaseAPI {
    /**
     * Create a pricing unit. 
     * @summary Create Pricing Unit
     * @param {PricingUnitForSave} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingUnitsApi
     */
    public createPricingUnit(body?: PricingUnitForSave, options?: AxiosRequestConfig) {
        return PricingUnitsApiFp(this.configuration).createPricingUnit(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a pricing unit. 
     * @summary Delete Pricing Unit
     * @param {string} pricingUnitId Unit ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingUnitsApi
     */
    public deletePricingUnit(pricingUnitId: string, options?: AxiosRequestConfig) {
        return PricingUnitsApiFp(this.configuration).deletePricingUnit(pricingUnitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a pricing unit. 
     * @summary Get Pricing Unit
     * @param {string} pricingUnitId Unit ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingUnitsApi
     */
    public getPricingUnit(pricingUnitId: string, options?: AxiosRequestConfig) {
        return PricingUnitsApiFp(this.configuration).getPricingUnit(pricingUnitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the smallest unit of measure on which the charges are based. \"Fixed Unit\" (type=fixed) is a unit of a monthly fixed charge such as a basic charge, \"Usage Unit\" (type=usage) is a unit in which a charge is generated per unit such as billing for the number of users, \"Tiered Unit\" (type=tiered) is a fixed charge unit for each tier of usage, such as the tiered packet charge for mobile phones, \"Tiered Usage Unit\" (type=tiered_usage) is a unit where the charge per unit changes according to the usage amount, such as a volume discount. 
     * @summary Get Pricing Units
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingUnitsApi
     */
    public getPricingUnits(options?: AxiosRequestConfig) {
        return PricingUnitsApiFp(this.configuration).getPricingUnits(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update pricing unit. 
     * @summary Update Pricing Unit
     * @param {string} pricingUnitId Unit ID
     * @param {PricingUnitForSave} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PricingUnitsApi
     */
    public updatePricingUnit(pricingUnitId: string, body?: PricingUnitForSave, options?: AxiosRequestConfig) {
        return PricingUnitsApiFp(this.configuration).updatePricingUnit(pricingUnitId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaxRateApi - axios parameter creator
 * @export
 */
export const TaxRateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a tax rate. 
         * @summary Create Tax Rate
         * @param {TaxRateProps} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaxRate: async (body?: TaxRateProps, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tax-rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all Tax Rates 
         * @summary Get Tax Rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxRates: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tax-rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tax rate. 
         * @summary Update Tax Rate
         * @param {string} taxRateId Tax Rate ID
         * @param {UpdateTaxRateParam} [updateTaxRateParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxRate: async (taxRateId: string, updateTaxRateParam?: UpdateTaxRateParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taxRateId' is not null or undefined
            assertParamExists('updateTaxRate', 'taxRateId', taxRateId)
            const localVarPath = `/tax-rates/{tax_rate_id}`
                .replace(`{${"tax_rate_id"}}`, encodeURIComponent(String(taxRateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaxRateParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaxRateApi - functional programming interface
 * @export
 */
export const TaxRateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaxRateApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a tax rate. 
         * @summary Create Tax Rate
         * @param {TaxRateProps} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaxRate(body?: TaxRateProps, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxRate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaxRate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all Tax Rates 
         * @summary Get Tax Rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaxRates(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxRates>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaxRates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tax rate. 
         * @summary Update Tax Rate
         * @param {string} taxRateId Tax Rate ID
         * @param {UpdateTaxRateParam} [updateTaxRateParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTaxRate(taxRateId: string, updateTaxRateParam?: UpdateTaxRateParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTaxRate(taxRateId, updateTaxRateParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaxRateApi - factory interface
 * @export
 */
export const TaxRateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaxRateApiFp(configuration)
    return {
        /**
         * Creates a tax rate. 
         * @summary Create Tax Rate
         * @param {TaxRateProps} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaxRate(body?: TaxRateProps, options?: any): AxiosPromise<TaxRate> {
            return localVarFp.createTaxRate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all Tax Rates 
         * @summary Get Tax Rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxRates(options?: any): AxiosPromise<TaxRates> {
            return localVarFp.getTaxRates(options).then((request) => request(axios, basePath));
        },
        /**
         * Update tax rate. 
         * @summary Update Tax Rate
         * @param {string} taxRateId Tax Rate ID
         * @param {UpdateTaxRateParam} [updateTaxRateParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxRate(taxRateId: string, updateTaxRateParam?: UpdateTaxRateParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateTaxRate(taxRateId, updateTaxRateParam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaxRateApi - object-oriented interface
 * @export
 * @class TaxRateApi
 * @extends {BaseAPI}
 */
export class TaxRateApi extends BaseAPI {
    /**
     * Creates a tax rate. 
     * @summary Create Tax Rate
     * @param {TaxRateProps} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxRateApi
     */
    public createTaxRate(body?: TaxRateProps, options?: AxiosRequestConfig) {
        return TaxRateApiFp(this.configuration).createTaxRate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all Tax Rates 
     * @summary Get Tax Rates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxRateApi
     */
    public getTaxRates(options?: AxiosRequestConfig) {
        return TaxRateApiFp(this.configuration).getTaxRates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tax rate. 
     * @summary Update Tax Rate
     * @param {string} taxRateId Tax Rate ID
     * @param {UpdateTaxRateParam} [updateTaxRateParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxRateApi
     */
    public updateTaxRate(taxRateId: string, updateTaxRateParam?: UpdateTaxRateParam, options?: AxiosRequestConfig) {
        return TaxRateApiFp(this.configuration).updateTaxRate(taxRateId, updateTaxRateParam, options).then((request) => request(this.axios, this.basePath));
    }
}


