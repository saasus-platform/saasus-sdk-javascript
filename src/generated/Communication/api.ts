/* tslint:disable */
/* eslint-disable */
/**
 * SaaSus Communication API Schema
 * SaaSus Communication API Schema
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'user_id': string;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'body': string;
}
/**
 * 
 * @export
 * @interface CommentAllOf
 */
export interface CommentAllOf {
    /**
     * 
     * @type {string}
     * @memberof CommentAllOf
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CommentAllOf
     */
    'user_id': string;
    /**
     * 
     * @type {number}
     * @memberof CommentAllOf
     */
    'created_at': number;
    /**
     * 
     * @type {string}
     * @memberof CommentAllOf
     */
    'body': string;
}
/**
 * 
 * @export
 * @interface Comments
 */
export interface Comments {
    /**
     * 
     * @type {Array<Comment>}
     * @memberof Comments
     */
    'comments': Array<Comment>;
}
/**
 * 
 * @export
 * @interface CreateFeedbackCommentParam
 */
export interface CreateFeedbackCommentParam {
    /**
     * 
     * @type {string}
     * @memberof CreateFeedbackCommentParam
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFeedbackCommentParam
     */
    'body': string;
}
/**
 * 
 * @export
 * @interface CreateFeedbackParam
 */
export interface CreateFeedbackParam {
    /**
     * 
     * @type {string}
     * @memberof CreateFeedbackParam
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFeedbackParam
     */
    'feedback_title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFeedbackParam
     */
    'feedback_description': string;
}
/**
 * 
 * @export
 * @interface CreateFeedbackParamAllOf
 */
export interface CreateFeedbackParamAllOf {
    /**
     * 
     * @type {string}
     * @memberof CreateFeedbackParamAllOf
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface CreateVoteUserParam
 */
export interface CreateVoteUserParam {
    /**
     * 
     * @type {string}
     * @memberof CreateVoteUserParam
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface Feedback
 */
export interface Feedback {
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'user_id': string;
    /**
     * 
     * @type {number}
     * @memberof Feedback
     */
    'created_at': number;
    /**
     * 
     * @type {number}
     * @memberof Feedback
     */
    'status': number;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'feedback_title': string;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'feedback_description': string;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof Feedback
     */
    'comments': Array<Comment>;
    /**
     * 
     * @type {number}
     * @memberof Feedback
     */
    'count': number;
    /**
     * 
     * @type {Array<User>}
     * @memberof Feedback
     */
    'users': Array<User>;
}
/**
 * 
 * @export
 * @interface FeedbackAllOf
 */
export interface FeedbackAllOf {
    /**
     * 
     * @type {string}
     * @memberof FeedbackAllOf
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FeedbackAllOf
     */
    'user_id': string;
    /**
     * 
     * @type {number}
     * @memberof FeedbackAllOf
     */
    'created_at': number;
    /**
     * 
     * @type {number}
     * @memberof FeedbackAllOf
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface FeedbackSaveProps
 */
export interface FeedbackSaveProps {
    /**
     * 
     * @type {string}
     * @memberof FeedbackSaveProps
     */
    'feedback_title': string;
    /**
     * 
     * @type {string}
     * @memberof FeedbackSaveProps
     */
    'feedback_description': string;
}
/**
 * 
 * @export
 * @interface Feedbacks
 */
export interface Feedbacks {
    /**
     * 
     * @type {Array<Feedback>}
     * @memberof Feedbacks
     */
    'feedbacks': Array<Feedback>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * permission_denied
     * @type {string}
     * @memberof ModelError
     */
    'type': string;
    /**
     * Error message
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UpdateFeedbackCommentParam
 */
export interface UpdateFeedbackCommentParam {
    /**
     * 
     * @type {string}
     * @memberof UpdateFeedbackCommentParam
     */
    'body': string;
}
/**
 * 
 * @export
 * @interface UpdateFeedbackParam
 */
export interface UpdateFeedbackParam {
    /**
     * 
     * @type {string}
     * @memberof UpdateFeedbackParam
     */
    'feedback_title': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFeedbackParam
     */
    'feedback_description': string;
}
/**
 * 
 * @export
 * @interface UpdateFeedbackStatusParam
 */
export interface UpdateFeedbackStatusParam {
    /**
     * 
     * @type {number}
     * @memberof UpdateFeedbackStatusParam
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface Users
 */
export interface Users {
    /**
     * 
     * @type {Array<User>}
     * @memberof Users
     */
    'users': Array<User>;
}
/**
 * 
 * @export
 * @interface Votes
 */
export interface Votes {
    /**
     * 
     * @type {number}
     * @memberof Votes
     */
    'count': number;
    /**
     * 
     * @type {Array<User>}
     * @memberof Votes
     */
    'users': Array<User>;
}
/**
 * 
 * @export
 * @interface VotesAllOf
 */
export interface VotesAllOf {
    /**
     * 
     * @type {number}
     * @memberof VotesAllOf
     */
    'count': number;
}

/**
 * ErrorApi - axios parameter creator
 * @export
 */
export const ErrorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * テスト用途で使用するエンドポイントです。ステータスコード500でサーバーエラーを返却します。  This endpoint is used for testing purposes. Returns a server error with status code 500. 
         * @summary ステータスコード500でサーバーエラーを返却(Return Internal Server Error)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnInternalServerError: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/errors/internal-server-error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ErrorApi - functional programming interface
 * @export
 */
export const ErrorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ErrorApiAxiosParamCreator(configuration)
    return {
        /**
         * テスト用途で使用するエンドポイントです。ステータスコード500でサーバーエラーを返却します。  This endpoint is used for testing purposes. Returns a server error with status code 500. 
         * @summary ステータスコード500でサーバーエラーを返却(Return Internal Server Error)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async returnInternalServerError(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.returnInternalServerError(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ErrorApi - factory interface
 * @export
 */
export const ErrorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ErrorApiFp(configuration)
    return {
        /**
         * テスト用途で使用するエンドポイントです。ステータスコード500でサーバーエラーを返却します。  This endpoint is used for testing purposes. Returns a server error with status code 500. 
         * @summary ステータスコード500でサーバーエラーを返却(Return Internal Server Error)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnInternalServerError(options?: any): AxiosPromise<void> {
            return localVarFp.returnInternalServerError(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ErrorApi - object-oriented interface
 * @export
 * @class ErrorApi
 * @extends {BaseAPI}
 */
export class ErrorApi extends BaseAPI {
    /**
     * テスト用途で使用するエンドポイントです。ステータスコード500でサーバーエラーを返却します。  This endpoint is used for testing purposes. Returns a server error with status code 500. 
     * @summary ステータスコード500でサーバーエラーを返却(Return Internal Server Error)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorApi
     */
    public returnInternalServerError(options?: AxiosRequestConfig) {
        return ErrorApiFp(this.configuration).returnInternalServerError(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FeedbackApi - axios parameter creator
 * @export
 */
export const FeedbackApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * フィードバックを起票
         * @param {CreateFeedbackParam} [createFeedbackParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedback: async (createFeedbackParam?: CreateFeedbackParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feedbacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFeedbackParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * フィードバックへのコメント
         * @param {string} feedbackId 
         * @param {CreateFeedbackCommentParam} [createFeedbackCommentParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbackComment: async (feedbackId: string, createFeedbackCommentParam?: CreateFeedbackCommentParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackId' is not null or undefined
            assertParamExists('createFeedbackComment', 'feedbackId', feedbackId)
            const localVarPath = `/feedbacks/{feedback_id}/comments`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFeedbackCommentParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * フィードバックへの投票
         * @param {string} feedbackId 
         * @param {CreateVoteUserParam} [createVoteUserParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVoteUser: async (feedbackId: string, createVoteUserParam?: CreateVoteUserParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackId' is not null or undefined
            assertParamExists('createVoteUser', 'feedbackId', feedbackId)
            const localVarPath = `/feedbacks/{feedback_id}/votes/users`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVoteUserParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * フィードバックの削除
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedback: async (feedbackId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackId' is not null or undefined
            assertParamExists('deleteFeedback', 'feedbackId', feedbackId)
            const localVarPath = `/feedbacks/{feedback_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * フィードバックへのコメント削除
         * @param {string} feedbackId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedbackComment: async (feedbackId: string, commentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackId' is not null or undefined
            assertParamExists('deleteFeedbackComment', 'feedbackId', feedbackId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('deleteFeedbackComment', 'commentId', commentId)
            const localVarPath = `/feedbacks/{feedback_id}/comments/{comment_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)))
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * フィードバックへの投票の取消
         * @param {string} feedbackId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoteForFeedback: async (feedbackId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackId' is not null or undefined
            assertParamExists('deleteVoteForFeedback', 'feedbackId', feedbackId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteVoteForFeedback', 'userId', userId)
            const localVarPath = `/feedbacks/{feedback_id}/votes/users/{user_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * フィードバックの取得
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedback: async (feedbackId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackId' is not null or undefined
            assertParamExists('getFeedback', 'feedbackId', feedbackId)
            const localVarPath = `/feedbacks/{feedback_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * フィードバックへのコメント取得
         * @param {string} feedbackId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackComment: async (feedbackId: string, commentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackId' is not null or undefined
            assertParamExists('getFeedbackComment', 'feedbackId', feedbackId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('getFeedbackComment', 'commentId', commentId)
            const localVarPath = `/feedbacks/{feedback_id}/comments/{comment_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)))
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * フィードバックの一覧を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbacks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feedbacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * フィードバックの編集
         * @param {string} feedbackId 
         * @param {UpdateFeedbackParam} [updateFeedbackParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedback: async (feedbackId: string, updateFeedbackParam?: UpdateFeedbackParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackId' is not null or undefined
            assertParamExists('updateFeedback', 'feedbackId', feedbackId)
            const localVarPath = `/feedbacks/{feedback_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFeedbackParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * フィードバックへのコメント編集
         * @param {string} feedbackId 
         * @param {string} commentId 
         * @param {UpdateFeedbackCommentParam} [updateFeedbackCommentParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedbackComment: async (feedbackId: string, commentId: string, updateFeedbackCommentParam?: UpdateFeedbackCommentParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackId' is not null or undefined
            assertParamExists('updateFeedbackComment', 'feedbackId', feedbackId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('updateFeedbackComment', 'commentId', commentId)
            const localVarPath = `/feedbacks/{feedback_id}/comments/{comment_id}`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)))
                .replace(`{${"comment_id"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFeedbackCommentParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * フィードバックのステータス更新
         * @param {string} feedbackId 
         * @param {UpdateFeedbackStatusParam} [updateFeedbackStatusParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedbackStatus: async (feedbackId: string, updateFeedbackStatusParam?: UpdateFeedbackStatusParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackId' is not null or undefined
            assertParamExists('updateFeedbackStatus', 'feedbackId', feedbackId)
            const localVarPath = `/feedbacks/{feedback_id}/status`
                .replace(`{${"feedback_id"}}`, encodeURIComponent(String(feedbackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFeedbackStatusParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedbackApi - functional programming interface
 * @export
 */
export const FeedbackApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedbackApiAxiosParamCreator(configuration)
    return {
        /**
         * フィードバックを起票
         * @param {CreateFeedbackParam} [createFeedbackParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeedback(createFeedbackParam?: CreateFeedbackParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeedback(createFeedbackParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * フィードバックへのコメント
         * @param {string} feedbackId 
         * @param {CreateFeedbackCommentParam} [createFeedbackCommentParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeedbackComment(feedbackId: string, createFeedbackCommentParam?: CreateFeedbackCommentParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeedbackComment(feedbackId, createFeedbackCommentParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * フィードバックへの投票
         * @param {string} feedbackId 
         * @param {CreateVoteUserParam} [createVoteUserParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVoteUser(feedbackId: string, createVoteUserParam?: CreateVoteUserParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Votes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVoteUser(feedbackId, createVoteUserParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * フィードバックの削除
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeedback(feedbackId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFeedback(feedbackId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * フィードバックへのコメント削除
         * @param {string} feedbackId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeedbackComment(feedbackId: string, commentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFeedbackComment(feedbackId, commentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * フィードバックへの投票の取消
         * @param {string} feedbackId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVoteForFeedback(feedbackId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVoteForFeedback(feedbackId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * フィードバックの取得
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeedback(feedbackId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeedback(feedbackId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * フィードバックへのコメント取得
         * @param {string} feedbackId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeedbackComment(feedbackId: string, commentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeedbackComment(feedbackId, commentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * フィードバックの一覧を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeedbacks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feedbacks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeedbacks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * フィードバックの編集
         * @param {string} feedbackId 
         * @param {UpdateFeedbackParam} [updateFeedbackParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeedback(feedbackId: string, updateFeedbackParam?: UpdateFeedbackParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeedback(feedbackId, updateFeedbackParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * フィードバックへのコメント編集
         * @param {string} feedbackId 
         * @param {string} commentId 
         * @param {UpdateFeedbackCommentParam} [updateFeedbackCommentParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeedbackComment(feedbackId: string, commentId: string, updateFeedbackCommentParam?: UpdateFeedbackCommentParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeedbackComment(feedbackId, commentId, updateFeedbackCommentParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * フィードバックのステータス更新
         * @param {string} feedbackId 
         * @param {UpdateFeedbackStatusParam} [updateFeedbackStatusParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeedbackStatus(feedbackId: string, updateFeedbackStatusParam?: UpdateFeedbackStatusParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeedbackStatus(feedbackId, updateFeedbackStatusParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FeedbackApi - factory interface
 * @export
 */
export const FeedbackApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedbackApiFp(configuration)
    return {
        /**
         * フィードバックを起票
         * @param {CreateFeedbackParam} [createFeedbackParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedback(createFeedbackParam?: CreateFeedbackParam, options?: any): AxiosPromise<Feedback> {
            return localVarFp.createFeedback(createFeedbackParam, options).then((request) => request(axios, basePath));
        },
        /**
         * フィードバックへのコメント
         * @param {string} feedbackId 
         * @param {CreateFeedbackCommentParam} [createFeedbackCommentParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeedbackComment(feedbackId: string, createFeedbackCommentParam?: CreateFeedbackCommentParam, options?: any): AxiosPromise<Comment> {
            return localVarFp.createFeedbackComment(feedbackId, createFeedbackCommentParam, options).then((request) => request(axios, basePath));
        },
        /**
         * フィードバックへの投票
         * @param {string} feedbackId 
         * @param {CreateVoteUserParam} [createVoteUserParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVoteUser(feedbackId: string, createVoteUserParam?: CreateVoteUserParam, options?: any): AxiosPromise<Votes> {
            return localVarFp.createVoteUser(feedbackId, createVoteUserParam, options).then((request) => request(axios, basePath));
        },
        /**
         * フィードバックの削除
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedback(feedbackId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFeedback(feedbackId, options).then((request) => request(axios, basePath));
        },
        /**
         * フィードバックへのコメント削除
         * @param {string} feedbackId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeedbackComment(feedbackId: string, commentId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFeedbackComment(feedbackId, commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * フィードバックへの投票の取消
         * @param {string} feedbackId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoteForFeedback(feedbackId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteVoteForFeedback(feedbackId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * フィードバックの取得
         * @param {string} feedbackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedback(feedbackId: string, options?: any): AxiosPromise<Feedback> {
            return localVarFp.getFeedback(feedbackId, options).then((request) => request(axios, basePath));
        },
        /**
         * フィードバックへのコメント取得
         * @param {string} feedbackId 
         * @param {string} commentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbackComment(feedbackId: string, commentId: string, options?: any): AxiosPromise<Comment> {
            return localVarFp.getFeedbackComment(feedbackId, commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * フィードバックの一覧を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeedbacks(options?: any): AxiosPromise<Feedbacks> {
            return localVarFp.getFeedbacks(options).then((request) => request(axios, basePath));
        },
        /**
         * フィードバックの編集
         * @param {string} feedbackId 
         * @param {UpdateFeedbackParam} [updateFeedbackParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedback(feedbackId: string, updateFeedbackParam?: UpdateFeedbackParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateFeedback(feedbackId, updateFeedbackParam, options).then((request) => request(axios, basePath));
        },
        /**
         * フィードバックへのコメント編集
         * @param {string} feedbackId 
         * @param {string} commentId 
         * @param {UpdateFeedbackCommentParam} [updateFeedbackCommentParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedbackComment(feedbackId: string, commentId: string, updateFeedbackCommentParam?: UpdateFeedbackCommentParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateFeedbackComment(feedbackId, commentId, updateFeedbackCommentParam, options).then((request) => request(axios, basePath));
        },
        /**
         * フィードバックのステータス更新
         * @param {string} feedbackId 
         * @param {UpdateFeedbackStatusParam} [updateFeedbackStatusParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeedbackStatus(feedbackId: string, updateFeedbackStatusParam?: UpdateFeedbackStatusParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateFeedbackStatus(feedbackId, updateFeedbackStatusParam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeedbackApi - object-oriented interface
 * @export
 * @class FeedbackApi
 * @extends {BaseAPI}
 */
export class FeedbackApi extends BaseAPI {
    /**
     * フィードバックを起票
     * @param {CreateFeedbackParam} [createFeedbackParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public createFeedback(createFeedbackParam?: CreateFeedbackParam, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).createFeedback(createFeedbackParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * フィードバックへのコメント
     * @param {string} feedbackId 
     * @param {CreateFeedbackCommentParam} [createFeedbackCommentParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public createFeedbackComment(feedbackId: string, createFeedbackCommentParam?: CreateFeedbackCommentParam, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).createFeedbackComment(feedbackId, createFeedbackCommentParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * フィードバックへの投票
     * @param {string} feedbackId 
     * @param {CreateVoteUserParam} [createVoteUserParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public createVoteUser(feedbackId: string, createVoteUserParam?: CreateVoteUserParam, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).createVoteUser(feedbackId, createVoteUserParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * フィードバックの削除
     * @param {string} feedbackId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public deleteFeedback(feedbackId: string, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).deleteFeedback(feedbackId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * フィードバックへのコメント削除
     * @param {string} feedbackId 
     * @param {string} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public deleteFeedbackComment(feedbackId: string, commentId: string, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).deleteFeedbackComment(feedbackId, commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * フィードバックへの投票の取消
     * @param {string} feedbackId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public deleteVoteForFeedback(feedbackId: string, userId: string, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).deleteVoteForFeedback(feedbackId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * フィードバックの取得
     * @param {string} feedbackId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public getFeedback(feedbackId: string, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).getFeedback(feedbackId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * フィードバックへのコメント取得
     * @param {string} feedbackId 
     * @param {string} commentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public getFeedbackComment(feedbackId: string, commentId: string, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).getFeedbackComment(feedbackId, commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * フィードバックの一覧を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public getFeedbacks(options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).getFeedbacks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * フィードバックの編集
     * @param {string} feedbackId 
     * @param {UpdateFeedbackParam} [updateFeedbackParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public updateFeedback(feedbackId: string, updateFeedbackParam?: UpdateFeedbackParam, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).updateFeedback(feedbackId, updateFeedbackParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * フィードバックへのコメント編集
     * @param {string} feedbackId 
     * @param {string} commentId 
     * @param {UpdateFeedbackCommentParam} [updateFeedbackCommentParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public updateFeedbackComment(feedbackId: string, commentId: string, updateFeedbackCommentParam?: UpdateFeedbackCommentParam, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).updateFeedbackComment(feedbackId, commentId, updateFeedbackCommentParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * フィードバックのステータス更新
     * @param {string} feedbackId 
     * @param {UpdateFeedbackStatusParam} [updateFeedbackStatusParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public updateFeedbackStatus(feedbackId: string, updateFeedbackStatusParam?: UpdateFeedbackStatusParam, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).updateFeedbackStatus(feedbackId, updateFeedbackStatusParam, options).then((request) => request(this.axios, this.basePath));
    }
}


