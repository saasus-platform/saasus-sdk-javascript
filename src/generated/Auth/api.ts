/* tslint:disable */
/* eslint-disable */
/**
 * SaaSus Auth API Schema
 * Schema
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Account authentication settings ※ This function is not yet provided, so it cannot be changed or saved. 
 * @export
 * @interface AccountVerification
 */
export interface AccountVerification {
    /**
     * code: verification code link: verification link ※ This function is not yet provided, so it cannot be changed or saved. 
     * @type {string}
     * @memberof AccountVerification
     */
    'verification_method': AccountVerificationVerificationMethodEnum;
    /**
     * email: e-mail sms: SMS smsOrEmail: email if SMS is not possible 
     * @type {string}
     * @memberof AccountVerification
     */
    'sending_to': AccountVerificationSendingToEnum;
}

export const AccountVerificationVerificationMethodEnum = {
    Code: 'code',
    Link: 'link'
} as const;

export type AccountVerificationVerificationMethodEnum = typeof AccountVerificationVerificationMethodEnum[keyof typeof AccountVerificationVerificationMethodEnum];
export const AccountVerificationSendingToEnum = {
    Email: 'email',
    Sms: 'sms',
    SmsOrEmail: 'smsOrEmail'
} as const;

export type AccountVerificationSendingToEnum = typeof AccountVerificationSendingToEnum[keyof typeof AccountVerificationSendingToEnum];

/**
 * 
 * @export
 * @interface ApiKeys
 */
export interface ApiKeys {
    /**
     * API Key
     * @type {Array<string>}
     * @memberof ApiKeys
     */
    'api_keys': Array<string>;
}
/**
 * 
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * Attribute Name
     * @type {string}
     * @memberof Attribute
     */
    'attribute_name': string;
    /**
     * Display Name
     * @type {string}
     * @memberof Attribute
     */
    'display_name': string;
    /**
     * 
     * @type {AttributeType}
     * @memberof Attribute
     */
    'attribute_type': AttributeType;
}
/**
 * Type (date can be set to YYYY-MM-DD format.) 
 * @export
 * @enum {string}
 */

export const AttributeType = {
    String: 'string',
    Number: 'number',
    Bool: 'bool',
    Date: 'date'
} as const;

export type AttributeType = typeof AttributeType[keyof typeof AttributeType];


/**
 * 
 * @export
 * @interface AuthInfo
 */
export interface AuthInfo {
    /**
     * Redirect After Authentication
     * @type {string}
     * @memberof AuthInfo
     */
    'callback_url': string;
}
/**
 * 
 * @export
 * @interface AuthorizationTempCode
 */
export interface AuthorizationTempCode {
    /**
     * 
     * @type {string}
     * @memberof AuthorizationTempCode
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface BasicInfo
 */
export interface BasicInfo {
    /**
     * Domain Name
     * @type {string}
     * @memberof BasicInfo
     */
    'domain_name': string;
    /**
     * DNS Record Verification Results
     * @type {boolean}
     * @memberof BasicInfo
     */
    'is_dns_validated': boolean;
    /**
     * 
     * @type {DnsRecord}
     * @memberof BasicInfo
     */
    'certificate_dns_record': DnsRecord;
    /**
     * 
     * @type {DnsRecord}
     * @memberof BasicInfo
     */
    'cloud_front_dns_record': DnsRecord;
    /**
     * DKIM DNS Records
     * @type {Array<DnsRecord>}
     * @memberof BasicInfo
     */
    'dkim_dns_records': Array<DnsRecord>;
    /**
     * Default Domain Name
     * @type {string}
     * @memberof BasicInfo
     */
    'default_domain_name': string;
    /**
     * Sender Email for Authentication Email
     * @type {string}
     * @memberof BasicInfo
     */
    'from_email_address': string;
    /**
     * Reply-from email address of authentication email
     * @type {string}
     * @memberof BasicInfo
     */
    'reply_email_address': string;
    /**
     * SES sandbox release and Cognito SES configuration results
     * @type {boolean}
     * @memberof BasicInfo
     */
    'is_ses_sandbox_granted': boolean;
}
/**
 * 
 * @export
 * @interface BillingAddress
 */
export interface BillingAddress {
    /**
     * Street address, apartment or suite number.
     * @type {string}
     * @memberof BillingAddress
     */
    'street': string;
    /**
     * City, district, suburb, town, or village.
     * @type {string}
     * @memberof BillingAddress
     */
    'city': string;
    /**
     * State name or abbreviation.
     * @type {string}
     * @memberof BillingAddress
     */
    'state': string;
    /**
     * Country of the address using ISO 3166-1 alpha-2 code.
     * @type {string}
     * @memberof BillingAddress
     */
    'country': string;
    /**
     * Additional information about the address, such as a building name, floor, or department name.
     * @type {string}
     * @memberof BillingAddress
     */
    'additional_address_info'?: string;
    /**
     * ZIP or postal code.
     * @type {string}
     * @memberof BillingAddress
     */
    'postal_code': string;
}
/**
 * 
 * @export
 * @interface BillingInfo
 */
export interface BillingInfo {
    /**
     * Tenant name for billing
     * @type {string}
     * @memberof BillingInfo
     */
    'name': string;
    /**
     * 
     * @type {BillingAddress}
     * @memberof BillingInfo
     */
    'address': BillingAddress;
    /**
     * 
     * @type {InvoiceLanguage}
     * @memberof BillingInfo
     */
    'invoice_language': InvoiceLanguage;
}
/**
 * 
 * @export
 * @interface ClientSecret
 */
export interface ClientSecret {
    /**
     * Client Secret
     * @type {string}
     * @memberof ClientSecret
     */
    'client_secret': string;
}
/**
 * 
 * @export
 * @interface CloudFormationLaunchStackLink
 */
export interface CloudFormationLaunchStackLink {
    /**
     * 
     * @type {string}
     * @memberof CloudFormationLaunchStackLink
     */
    'link': string;
}
/**
 * 
 * @export
 * @interface ConfirmEmailUpdateParam
 */
export interface ConfirmEmailUpdateParam {
    /**
     * 
     * @type {string}
     * @memberof ConfirmEmailUpdateParam
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ConfirmEmailUpdateParam
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface ConfirmExternalUserLinkParam
 */
export interface ConfirmExternalUserLinkParam {
    /**
     * 
     * @type {string}
     * @memberof ConfirmExternalUserLinkParam
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof ConfirmExternalUserLinkParam
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface ConfirmSignUpWithAwsMarketplaceParam
 */
export interface ConfirmSignUpWithAwsMarketplaceParam {
    /**
     * Tenant name
     * @type {string}
     * @memberof ConfirmSignUpWithAwsMarketplaceParam
     */
    'tenant_name'?: string;
    /**
     * Access token
     * @type {string}
     * @memberof ConfirmSignUpWithAwsMarketplaceParam
     */
    'access_token': string;
    /**
     * Registration Token
     * @type {string}
     * @memberof ConfirmSignUpWithAwsMarketplaceParam
     */
    'registration_token': string;
}
/**
 * 
 * @export
 * @interface CreateSaasUserParam
 */
export interface CreateSaasUserParam {
    /**
     * E-mail
     * @type {string}
     * @memberof CreateSaasUserParam
     */
    'email': string;
    /**
     * Password
     * @type {string}
     * @memberof CreateSaasUserParam
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface CreateSecretCodeParam
 */
export interface CreateSecretCodeParam {
    /**
     * access token
     * @type {string}
     * @memberof CreateSecretCodeParam
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface CreateTenantInvitationParam
 */
export interface CreateTenantInvitationParam {
    /**
     * Email address of the user to be invited
     * @type {string}
     * @memberof CreateTenantInvitationParam
     */
    'email': string;
    /**
     * Access token of the user who creates an invitation
     * @type {string}
     * @memberof CreateTenantInvitationParam
     */
    'access_token': string;
    /**
     * 
     * @type {Array<InvitedUserEnvironmentInformationInner>}
     * @memberof CreateTenantInvitationParam
     */
    'envs': Array<InvitedUserEnvironmentInformationInner>;
}
/**
 * 
 * @export
 * @interface CreateTenantUserParam
 */
export interface CreateTenantUserParam {
    /**
     * E-mail
     * @type {string}
     * @memberof CreateTenantUserParam
     */
    'email': string;
    /**
     * Attribute information (Get information set by defining user attributes in the SaaS development console) 
     * @type {{ [key: string]: any; }}
     * @memberof CreateTenantUserParam
     */
    'attributes': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface CreateTenantUserRolesParam
 */
export interface CreateTenantUserRolesParam {
    /**
     * Role Info
     * @type {Array<string>}
     * @memberof CreateTenantUserRolesParam
     */
    'role_names': Array<string>;
}
/**
 * 
 * @export
 * @interface Credentials
 */
export interface Credentials {
    /**
     * ID token
     * @type {string}
     * @memberof Credentials
     */
    'id_token': string;
    /**
     * Access token
     * @type {string}
     * @memberof Credentials
     */
    'access_token': string;
    /**
     * Refresh token
     * @type {string}
     * @memberof Credentials
     */
    'refresh_token'?: string;
}
/**
 * 
 * @export
 * @interface CustomizePageProps
 */
export interface CustomizePageProps {
    /**
     * Edit page HTML ※ This function is not yet provided, so it cannot be changed or saved. 
     * @type {string}
     * @memberof CustomizePageProps
     */
    'html_contents': string;
    /**
     * display the terms of use agreement check box
     * @type {boolean}
     * @memberof CustomizePageProps
     */
    'is_terms_of_service': boolean;
    /**
     * show the privacy policy checkbox
     * @type {boolean}
     * @memberof CustomizePageProps
     */
    'is_privacy_policy': boolean;
}
/**
 * 
 * @export
 * @interface CustomizePageSettings
 */
export interface CustomizePageSettings {
    /**
     * service icon
     * @type {string}
     * @memberof CustomizePageSettings
     */
    'icon': string;
    /**
     * favicon
     * @type {string}
     * @memberof CustomizePageSettings
     */
    'favicon': string;
    /**
     * service name
     * @type {string}
     * @memberof CustomizePageSettings
     */
    'title': string;
    /**
     * terms of service URL
     * @type {string}
     * @memberof CustomizePageSettings
     */
    'terms_of_service_url': string;
    /**
     * privacy policy URL
     * @type {string}
     * @memberof CustomizePageSettings
     */
    'privacy_policy_url': string;
    /**
     * Google Tag Manager container ID
     * @type {string}
     * @memberof CustomizePageSettings
     */
    'google_tag_manager_container_id': string;
}
/**
 * 
 * @export
 * @interface CustomizePageSettingsAllOf
 */
export interface CustomizePageSettingsAllOf {
    /**
     * service icon
     * @type {string}
     * @memberof CustomizePageSettingsAllOf
     */
    'icon': string;
    /**
     * favicon
     * @type {string}
     * @memberof CustomizePageSettingsAllOf
     */
    'favicon': string;
}
/**
 * 
 * @export
 * @interface CustomizePageSettingsProps
 */
export interface CustomizePageSettingsProps {
    /**
     * service name
     * @type {string}
     * @memberof CustomizePageSettingsProps
     */
    'title': string;
    /**
     * terms of service URL
     * @type {string}
     * @memberof CustomizePageSettingsProps
     */
    'terms_of_service_url': string;
    /**
     * privacy policy URL
     * @type {string}
     * @memberof CustomizePageSettingsProps
     */
    'privacy_policy_url': string;
    /**
     * Google Tag Manager container ID
     * @type {string}
     * @memberof CustomizePageSettingsProps
     */
    'google_tag_manager_container_id': string;
}
/**
 * 
 * @export
 * @interface CustomizePages
 */
export interface CustomizePages {
    /**
     * 
     * @type {CustomizePageProps}
     * @memberof CustomizePages
     */
    'sign_up_page': CustomizePageProps;
    /**
     * 
     * @type {CustomizePageProps}
     * @memberof CustomizePages
     */
    'sign_in_page': CustomizePageProps;
    /**
     * 
     * @type {CustomizePageProps}
     * @memberof CustomizePages
     */
    'password_reset_page': CustomizePageProps;
}
/**
 * Settings for remembering trusted devices
 * @export
 * @interface DeviceConfiguration
 */
export interface DeviceConfiguration {
    /**
     * always: always remember userOptIn: user opt-in no: don\'t save 
     * @type {string}
     * @memberof DeviceConfiguration
     */
    'device_remembering': DeviceConfigurationDeviceRememberingEnum;
}

export const DeviceConfigurationDeviceRememberingEnum = {
    Always: 'always',
    UserOptIn: 'userOptIn',
    No: 'no'
} as const;

export type DeviceConfigurationDeviceRememberingEnum = typeof DeviceConfigurationDeviceRememberingEnum[keyof typeof DeviceConfigurationDeviceRememberingEnum];

/**
 * 
 * @export
 * @interface DnsRecord
 */
export interface DnsRecord {
    /**
     * CNAME Resource Record
     * @type {string}
     * @memberof DnsRecord
     */
    'type': DnsRecordTypeEnum;
    /**
     * Record Name
     * @type {string}
     * @memberof DnsRecord
     */
    'name': string;
    /**
     * Value
     * @type {string}
     * @memberof DnsRecord
     */
    'value': string;
}

export const DnsRecordTypeEnum = {
    Cname: 'CNAME'
} as const;

export type DnsRecordTypeEnum = typeof DnsRecordTypeEnum[keyof typeof DnsRecordTypeEnum];

/**
 * env info
 * @export
 * @interface Env
 */
export interface Env {
    /**
     * 
     * @type {number}
     * @memberof Env
     */
    'id': number;
    /**
     * env name
     * @type {string}
     * @memberof Env
     */
    'name': string;
    /**
     * env display name
     * @type {string}
     * @memberof Env
     */
    'display_name'?: string;
}
/**
 * env list
 * @export
 * @interface Envs
 */
export interface Envs {
    /**
     * 
     * @type {Array<Env>}
     * @memberof Envs
     */
    'envs': Array<Env>;
}
/**
 * This information is required to set up sign-in using an external identity provider. It cannot be changed. 
 * @export
 * @interface IdentityProviderConfiguration
 */
export interface IdentityProviderConfiguration {
    /**
     * domain
     * @type {string}
     * @memberof IdentityProviderConfiguration
     */
    'domain': string;
    /**
     * redirect URL
     * @type {string}
     * @memberof IdentityProviderConfiguration
     */
    'redirect_url': string;
    /**
     * entity ID
     * @type {string}
     * @memberof IdentityProviderConfiguration
     */
    'entity_id': string;
    /**
     * reply URL
     * @type {string}
     * @memberof IdentityProviderConfiguration
     */
    'reply_url': string;
}
/**
 * 
 * @export
 * @interface IdentityProviderProps
 */
export interface IdentityProviderProps {
    /**
     * 
     * @type {string}
     * @memberof IdentityProviderProps
     */
    'application_id': string;
    /**
     * 
     * @type {string}
     * @memberof IdentityProviderProps
     */
    'application_secret': string;
    /**
     * 
     * @type {string}
     * @memberof IdentityProviderProps
     */
    'approval_scope': string;
    /**
     * 
     * @type {boolean}
     * @memberof IdentityProviderProps
     */
    'is_button_hidden'?: boolean;
}
/**
 * 
 * @export
 * @interface IdentityProviderSaml
 */
export interface IdentityProviderSaml {
    /**
     * 
     * @type {string}
     * @memberof IdentityProviderSaml
     */
    'metadata_url': string;
    /**
     * 
     * @type {string}
     * @memberof IdentityProviderSaml
     */
    'email_attribute': string;
}
/**
 * 
 * @export
 * @interface IdentityProviders
 */
export interface IdentityProviders {
    /**
     * 
     * @type {IdentityProviderProps}
     * @memberof IdentityProviders
     */
    'google': IdentityProviderProps;
}
/**
 * 
 * @export
 * @interface Invitation
 */
export interface Invitation {
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    'id': string;
    /**
     * Email address of the invited user
     * @type {string}
     * @memberof Invitation
     */
    'email': string;
    /**
     * Invitation URL
     * @type {string}
     * @memberof Invitation
     */
    'invitation_url': string;
    /**
     * 
     * @type {Array<UserAvailableEnv>}
     * @memberof Invitation
     */
    'envs': Array<UserAvailableEnv>;
    /**
     * Expiration date of the invitation
     * @type {number}
     * @memberof Invitation
     */
    'expired_at': number;
    /**
     * 
     * @type {InvitationStatus}
     * @memberof Invitation
     */
    'status': InvitationStatus;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const InvitationStatus = {
    Pending: 'pending',
    Accepted: 'accepted',
    Expired: 'expired'
} as const;

export type InvitationStatus = typeof InvitationStatus[keyof typeof InvitationStatus];


/**
 * Invitation validity
 * @export
 * @interface InvitationValidity
 */
export interface InvitationValidity {
    /**
     * Whether the validation is valid or not
     * @type {boolean}
     * @memberof InvitationValidity
     */
    'is_valid': boolean;
}
/**
 * 
 * @export
 * @interface Invitations
 */
export interface Invitations {
    /**
     * Invitation list
     * @type {Array<Invitation>}
     * @memberof Invitations
     */
    'invitations': Array<Invitation>;
}
/**
 * 
 * @export
 * @interface InvitedUserEnvironmentInformationInner
 */
export interface InvitedUserEnvironmentInformationInner {
    /**
     * 
     * @type {number}
     * @memberof InvitedUserEnvironmentInformationInner
     */
    'id': number;
    /**
     * Role name
     * @type {Array<string>}
     * @memberof InvitedUserEnvironmentInformationInner
     */
    'role_names': Array<string>;
}
/**
 * Language of invoice
 * @export
 * @enum {string}
 */

export const InvoiceLanguage = {
    JaJp: 'ja-JP',
    EnUs: 'en-US'
} as const;

export type InvoiceLanguage = typeof InvoiceLanguage[keyof typeof InvoiceLanguage];


/**
 * 
 * @export
 * @interface LinkAwsMarketplaceParam
 */
export interface LinkAwsMarketplaceParam {
    /**
     * Tenant ID
     * @type {string}
     * @memberof LinkAwsMarketplaceParam
     */
    'tenant_id': string;
    /**
     * Access token
     * @type {string}
     * @memberof LinkAwsMarketplaceParam
     */
    'access_token': string;
    /**
     * Registration Token
     * @type {string}
     * @memberof LinkAwsMarketplaceParam
     */
    'registration_token': string;
}
/**
 * 
 * @export
 * @interface MessageTemplate
 */
export interface MessageTemplate {
    /**
     * Title
     * @type {string}
     * @memberof MessageTemplate
     */
    'subject': string;
    /**
     * Message
     * @type {string}
     * @memberof MessageTemplate
     */
    'message': string;
}
/**
 * MFA device authentication settings ※ This function is not yet provided, so it cannot be changed or saved. 
 * @export
 * @interface MfaConfiguration
 */
export interface MfaConfiguration {
    /**
     * on: apply when all users log in optional: apply to individual users with MFA factor enabled ※ The parameter is currently optional and fixed. 
     * @type {string}
     * @memberof MfaConfiguration
     */
    'mfa_configuration': MfaConfigurationMfaConfigurationEnum;
}

export const MfaConfigurationMfaConfigurationEnum = {
    On: 'on',
    Optional: 'optional'
} as const;

export type MfaConfigurationMfaConfigurationEnum = typeof MfaConfigurationMfaConfigurationEnum[keyof typeof MfaConfigurationMfaConfigurationEnum];

/**
 * 
 * @export
 * @interface MfaPreference
 */
export interface MfaPreference {
    /**
     * enable MFA
     * @type {boolean}
     * @memberof MfaPreference
     */
    'enabled': boolean;
    /**
     * MFA method (required if enabled is true)
     * @type {string}
     * @memberof MfaPreference
     */
    'method'?: MfaPreferenceMethodEnum;
}

export const MfaPreferenceMethodEnum = {
    SoftwareToken: 'softwareToken'
} as const;

export type MfaPreferenceMethodEnum = typeof MfaPreferenceMethodEnum[keyof typeof MfaPreferenceMethodEnum];

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * permission_denied
     * @type {string}
     * @memberof ModelError
     */
    'type': string;
    /**
     * Error message
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModelError
     */
    'data'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface NotificationMessages
 */
export interface NotificationMessages {
    /**
     * 
     * @type {MessageTemplate}
     * @memberof NotificationMessages
     */
    'sign_up': MessageTemplate;
    /**
     * 
     * @type {MessageTemplate}
     * @memberof NotificationMessages
     */
    'create_user': MessageTemplate;
    /**
     * 
     * @type {MessageTemplate}
     * @memberof NotificationMessages
     */
    'resend_code': MessageTemplate;
    /**
     * 
     * @type {MessageTemplate}
     * @memberof NotificationMessages
     */
    'forgot_password': MessageTemplate;
    /**
     * 
     * @type {MessageTemplate}
     * @memberof NotificationMessages
     */
    'update_user_attribute': MessageTemplate;
    /**
     * 
     * @type {MessageTemplate}
     * @memberof NotificationMessages
     */
    'verify_user_attribute': MessageTemplate;
    /**
     * 
     * @type {MessageTemplate}
     * @memberof NotificationMessages
     */
    'authentication_mfa': MessageTemplate;
    /**
     * 
     * @type {MessageTemplate}
     * @memberof NotificationMessages
     */
    'invite_tenant_user': MessageTemplate;
    /**
     * 
     * @type {MessageTemplate}
     * @memberof NotificationMessages
     */
    'verify_external_user': MessageTemplate;
}
/**
 * Password Policy
 * @export
 * @interface PasswordPolicy
 */
export interface PasswordPolicy {
    /**
     * Minimum number of characters
     * @type {number}
     * @memberof PasswordPolicy
     */
    'minimum_length': number;
    /**
     * Contains one or more lowercase characters
     * @type {boolean}
     * @memberof PasswordPolicy
     */
    'is_require_lowercase': boolean;
    /**
     * Contains one or more numeric characters
     * @type {boolean}
     * @memberof PasswordPolicy
     */
    'is_require_numbers': boolean;
    /**
     * Contains one or more special characters
     * @type {boolean}
     * @memberof PasswordPolicy
     */
    'is_require_symbols': boolean;
    /**
     * Contains one or more uppercase letters
     * @type {boolean}
     * @memberof PasswordPolicy
     */
    'is_require_uppercase': boolean;
    /**
     * Temporary password expiration date
     * @type {number}
     * @memberof PasswordPolicy
     */
    'temporary_password_validity_days': number;
}
/**
 * 
 * @export
 * @interface PlanHistories
 */
export interface PlanHistories {
    /**
     * Plan History
     * @type {Array<PlanHistory>}
     * @memberof PlanHistories
     */
    'plan_histories': Array<PlanHistory>;
}
/**
 * 
 * @export
 * @interface PlanHistory
 */
export interface PlanHistory {
    /**
     * 
     * @type {string}
     * @memberof PlanHistory
     */
    'plan_id': string;
    /**
     * Registration date
     * @type {number}
     * @memberof PlanHistory
     */
    'plan_applied_at': number;
    /**
     * 
     * @type {string}
     * @memberof PlanHistory
     */
    'tax_rate_id'?: string;
    /**
     * 
     * @type {ProrationBehavior}
     * @memberof PlanHistory
     */
    'proration_behavior'?: ProrationBehavior;
    /**
     * If you have a stripe linkage,  you can set whether to delete pay-as-you-go items when changing plans. When you change plan, you can remove all pay-as-you-go items included in your current subscription to stop being billed based on pay-as-you-go items. The recorded usage is cleared immediately. Since it cannot be restored, please note that plan change reservations with delete_usage set to true cannot be canceled. 
     * @type {boolean}
     * @memberof PlanHistory
     */
    'delete_usage'?: boolean;
}
/**
 * 
 * @export
 * @interface PlanReservation
 */
export interface PlanReservation {
    /**
     * 
     * @type {string}
     * @memberof PlanReservation
     */
    'next_plan_id'?: string;
    /**
     * Next billing plan start time (When using stripe, you can create a subscription that starts at the beginning of the current month by specifying 00:00 (UTC) at the beginning of the current month. Ex. 1672531200 for January 2023.) 
     * @type {number}
     * @memberof PlanReservation
     */
    'using_next_plan_from'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlanReservation
     */
    'next_plan_tax_rate_id'?: string;
    /**
     * 
     * @type {ProrationBehavior}
     * @memberof PlanReservation
     */
    'proration_behavior'?: ProrationBehavior;
    /**
     * If you have a stripe linkage,  you can set whether to delete pay-as-you-go items when changing plans. When you change plan, you can remove all pay-as-you-go items included in your current subscription to stop being billed based on pay-as-you-go items. The recorded usage is cleared immediately. Since it cannot be restored, please note that plan change reservations with delete_usage set to true cannot be canceled. 
     * @type {boolean}
     * @memberof PlanReservation
     */
    'delete_usage'?: boolean;
}
/**
 * If you have a strine linkage, you can set the behavior of the proportional allocation when changing plans. When a plan is changed, you can set whether to prorate the billing amount and reflect it on the next invoice, to issue a prorated invoice immediately, or not to prorate at all. 
 * @export
 * @enum {string}
 */

export const ProrationBehavior = {
    CreateProrations: 'create_prorations',
    None: 'none',
    AlwaysInvoice: 'always_invoice'
} as const;

export type ProrationBehavior = typeof ProrationBehavior[keyof typeof ProrationBehavior];


/**
 * 
 * @export
 * @enum {string}
 */

export const ProviderName = {
    Google: 'Google'
} as const;

export type ProviderName = typeof ProviderName[keyof typeof ProviderName];


/**
 * 
 * @export
 * @enum {string}
 */

export const ProviderType = {
    Saml: 'SAML'
} as const;

export type ProviderType = typeof ProviderType[keyof typeof ProviderType];


/**
 * reCAPTCHA authentication settings ※ This function is not yet provided, so it cannot be changed or saved. 
 * @export
 * @interface RecaptchaProps
 */
export interface RecaptchaProps {
    /**
     * site key
     * @type {string}
     * @memberof RecaptchaProps
     */
    'site_key': string;
    /**
     * secret key
     * @type {string}
     * @memberof RecaptchaProps
     */
    'secret_key': string;
}
/**
 * 
 * @export
 * @interface RequestEmailUpdateParam
 */
export interface RequestEmailUpdateParam {
    /**
     * Email Address
     * @type {string}
     * @memberof RequestEmailUpdateParam
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RequestEmailUpdateParam
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface RequestExternalUserLinkParam
 */
export interface RequestExternalUserLinkParam {
    /**
     * 
     * @type {string}
     * @memberof RequestExternalUserLinkParam
     */
    'access_token': string;
}
/**
 * 
 * @export
 * @interface ResendSignUpConfirmationEmailParam
 */
export interface ResendSignUpConfirmationEmailParam {
    /**
     * Email Address
     * @type {string}
     * @memberof ResendSignUpConfirmationEmailParam
     */
    'email': string;
}
/**
 * role info
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * role name
     * @type {string}
     * @memberof Role
     */
    'role_name': string;
    /**
     * role display name
     * @type {string}
     * @memberof Role
     */
    'display_name': string;
}
/**
 * 
 * @export
 * @interface Roles
 */
export interface Roles {
    /**
     * 
     * @type {Array<Role>}
     * @memberof Roles
     */
    'roles': Array<Role>;
}
/**
 * 
 * @export
 * @interface SaasId
 */
export interface SaasId {
    /**
     * 
     * @type {string}
     * @memberof SaasId
     */
    'tenant_id': string;
    /**
     * 
     * @type {number}
     * @memberof SaasId
     */
    'env_id': number;
    /**
     * SaaS ID
     * @type {string}
     * @memberof SaasId
     */
    'saas_id': string;
}
/**
 * 
 * @export
 * @interface SaasUser
 */
export interface SaasUser {
    /**
     * 
     * @type {string}
     * @memberof SaasUser
     */
    'id': string;
    /**
     * E-mail
     * @type {string}
     * @memberof SaasUser
     */
    'email': string;
    /**
     * Attribute information 
     * @type {{ [key: string]: any; }}
     * @memberof SaasUser
     */
    'attributes': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface SaasUsers
 */
export interface SaasUsers {
    /**
     * 
     * @type {Array<SaasUser>}
     * @memberof SaasUsers
     */
    'users': Array<SaasUser>;
}
/**
 * self sign-up permission
 * @export
 * @interface SelfRegist
 */
export interface SelfRegist {
    /**
     * 
     * @type {boolean}
     * @memberof SelfRegist
     */
    'enable': boolean;
}
/**
 * 
 * @export
 * @interface SignInSettings
 */
export interface SignInSettings {
    /**
     * 
     * @type {PasswordPolicy}
     * @memberof SignInSettings
     */
    'password_policy': PasswordPolicy;
    /**
     * 
     * @type {DeviceConfiguration}
     * @memberof SignInSettings
     */
    'device_configuration': DeviceConfiguration;
    /**
     * 
     * @type {MfaConfiguration}
     * @memberof SignInSettings
     */
    'mfa_configuration': MfaConfiguration;
    /**
     * 
     * @type {RecaptchaProps}
     * @memberof SignInSettings
     */
    'recaptcha_props': RecaptchaProps;
    /**
     * 
     * @type {AccountVerification}
     * @memberof SignInSettings
     */
    'account_verification': AccountVerification;
    /**
     * 
     * @type {SelfRegist}
     * @memberof SignInSettings
     */
    'self_regist': SelfRegist;
    /**
     * 
     * @type {IdentityProviderConfiguration}
     * @memberof SignInSettings
     */
    'identity_provider_configuration': IdentityProviderConfiguration;
}
/**
 * 
 * @export
 * @interface SignUpParam
 */
export interface SignUpParam {
    /**
     * Email Address
     * @type {string}
     * @memberof SignUpParam
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface SignUpWithAwsMarketplaceParam
 */
export interface SignUpWithAwsMarketplaceParam {
    /**
     * Email Address
     * @type {string}
     * @memberof SignUpWithAwsMarketplaceParam
     */
    'email': string;
    /**
     * Registration Token
     * @type {string}
     * @memberof SignUpWithAwsMarketplaceParam
     */
    'registration_token': string;
}
/**
 * 
 * @export
 * @interface SingleTenantSettings
 */
export interface SingleTenantSettings {
    /**
     * enable Single Tenant settings or not
     * @type {boolean}
     * @memberof SingleTenantSettings
     */
    'enabled': boolean;
    /**
     * ARN of the role for SaaS Platform to AssumeRole
     * @type {string}
     * @memberof SingleTenantSettings
     */
    'role_arn': string;
    /**
     * S3 URL where the CloudFormationTemplate to be executed in the SaaS environment is stored
     * @type {string}
     * @memberof SingleTenantSettings
     */
    'cloudformation_template_url': string;
    /**
     * S3 URL where the CloudFormationTemplate to be executed in the SaaS environment is stored
     * @type {string}
     * @memberof SingleTenantSettings
     */
    'ddl_template_url': string;
    /**
     * External id used by SaaSus when AssumeRole to operate SaaS
     * @type {string}
     * @memberof SingleTenantSettings
     */
    'role_external_id': string;
}
/**
 * 
 * @export
 * @interface SoftwareTokenSecretCode
 */
export interface SoftwareTokenSecretCode {
    /**
     * secret code
     * @type {string}
     * @memberof SoftwareTokenSecretCode
     */
    'secret_code': string;
}
/**
 * 
 * @export
 * @interface StripeCustomer
 */
export interface StripeCustomer {
    /**
     * stripe Customer ID
     * @type {string}
     * @memberof StripeCustomer
     */
    'customer_id': string;
    /**
     * stripe Subscription Schedule ID
     * @type {string}
     * @memberof StripeCustomer
     */
    'subscription_schedule_id': string;
}
/**
 * 
 * @export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'plan_id'?: string;
    /**
     * 
     * @type {BillingInfo}
     * @memberof Tenant
     */
    'billing_info'?: BillingInfo;
    /**
     * tenant name
     * @type {string}
     * @memberof Tenant
     */
    'name': string;
    /**
     * attribute info
     * @type {{ [key: string]: any; }}
     * @memberof Tenant
     */
    'attributes': { [key: string]: any; };
    /**
     * administrative staff email address
     * @type {string}
     * @memberof Tenant
     */
    'back_office_staff_email': string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'next_plan_id'?: string;
    /**
     * Next billing plan start time (When using stripe, you can create a subscription that starts at the beginning of the current month by specifying 00:00 (UTC) at the beginning of the current month. Ex. 1672531200 for January 2023.) 
     * @type {number}
     * @memberof Tenant
     */
    'using_next_plan_from'?: number;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'next_plan_tax_rate_id'?: string;
    /**
     * 
     * @type {ProrationBehavior}
     * @memberof Tenant
     */
    'proration_behavior'?: ProrationBehavior;
    /**
     * If you have a stripe linkage,  you can set whether to delete pay-as-you-go items when changing plans. When you change plan, you can remove all pay-as-you-go items included in your current subscription to stop being billed based on pay-as-you-go items. The recorded usage is cleared immediately. Since it cannot be restored, please note that plan change reservations with delete_usage set to true cannot be canceled. 
     * @type {boolean}
     * @memberof Tenant
     */
    'delete_usage'?: boolean;
    /**
     * Plan History
     * @type {Array<PlanHistory>}
     * @memberof Tenant
     */
    'plan_histories': Array<PlanHistory>;
}
/**
 * 
 * @export
 * @interface TenantAllOf
 */
export interface TenantAllOf {
    /**
     * 
     * @type {string}
     * @memberof TenantAllOf
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TenantAllOf
     */
    'plan_id'?: string;
    /**
     * 
     * @type {BillingInfo}
     * @memberof TenantAllOf
     */
    'billing_info'?: BillingInfo;
}
/**
 * 
 * @export
 * @interface TenantAttributes
 */
export interface TenantAttributes {
    /**
     * Tenant Attribute Definition
     * @type {Array<Attribute>}
     * @memberof TenantAttributes
     */
    'tenant_attributes': Array<Attribute>;
}
/**
 * 
 * @export
 * @interface TenantDetail
 */
export interface TenantDetail {
    /**
     * current plan period start
     * @type {number}
     * @memberof TenantDetail
     */
    'current_plan_period_start'?: number;
    /**
     * current plan period end
     * @type {number}
     * @memberof TenantDetail
     */
    'current_plan_period_end'?: number;
    /**
     * 
     * @type {string}
     * @memberof TenantDetail
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TenantDetail
     */
    'plan_id'?: string;
    /**
     * 
     * @type {BillingInfo}
     * @memberof TenantDetail
     */
    'billing_info'?: BillingInfo;
    /**
     * tenant name
     * @type {string}
     * @memberof TenantDetail
     */
    'name': string;
    /**
     * attribute info
     * @type {{ [key: string]: any; }}
     * @memberof TenantDetail
     */
    'attributes': { [key: string]: any; };
    /**
     * administrative staff email address
     * @type {string}
     * @memberof TenantDetail
     */
    'back_office_staff_email': string;
    /**
     * 
     * @type {string}
     * @memberof TenantDetail
     */
    'next_plan_id'?: string;
    /**
     * Next billing plan start time (When using stripe, you can create a subscription that starts at the beginning of the current month by specifying 00:00 (UTC) at the beginning of the current month. Ex. 1672531200 for January 2023.) 
     * @type {number}
     * @memberof TenantDetail
     */
    'using_next_plan_from'?: number;
    /**
     * 
     * @type {string}
     * @memberof TenantDetail
     */
    'next_plan_tax_rate_id'?: string;
    /**
     * 
     * @type {ProrationBehavior}
     * @memberof TenantDetail
     */
    'proration_behavior'?: ProrationBehavior;
    /**
     * If you have a stripe linkage,  you can set whether to delete pay-as-you-go items when changing plans. When you change plan, you can remove all pay-as-you-go items included in your current subscription to stop being billed based on pay-as-you-go items. The recorded usage is cleared immediately. Since it cannot be restored, please note that plan change reservations with delete_usage set to true cannot be canceled. 
     * @type {boolean}
     * @memberof TenantDetail
     */
    'delete_usage'?: boolean;
    /**
     * Plan History
     * @type {Array<PlanHistory>}
     * @memberof TenantDetail
     */
    'plan_histories': Array<PlanHistory>;
}
/**
 * 
 * @export
 * @interface TenantDetailAllOf
 */
export interface TenantDetailAllOf {
    /**
     * current plan period start
     * @type {number}
     * @memberof TenantDetailAllOf
     */
    'current_plan_period_start'?: number;
    /**
     * current plan period end
     * @type {number}
     * @memberof TenantDetailAllOf
     */
    'current_plan_period_end'?: number;
}
/**
 * @type TenantIdentityProviderProps
 * @export
 */
export type TenantIdentityProviderProps = IdentityProviderSaml;

/**
 * 
 * @export
 * @interface TenantIdentityProviders
 */
export interface TenantIdentityProviders {
    /**
     * 
     * @type {TenantIdentityProvidersSaml}
     * @memberof TenantIdentityProviders
     */
    'saml'?: TenantIdentityProvidersSaml;
}
/**
 * 
 * @export
 * @interface TenantIdentityProvidersSaml
 */
export interface TenantIdentityProvidersSaml {
    /**
     * 
     * @type {string}
     * @memberof TenantIdentityProvidersSaml
     */
    'sign_in_url': string;
    /**
     * 
     * @type {string}
     * @memberof TenantIdentityProvidersSaml
     */
    'metadata_url': string;
    /**
     * 
     * @type {string}
     * @memberof TenantIdentityProvidersSaml
     */
    'email_attribute': string;
}
/**
 * 
 * @export
 * @interface TenantIdentityProvidersSamlAllOf
 */
export interface TenantIdentityProvidersSamlAllOf {
    /**
     * 
     * @type {string}
     * @memberof TenantIdentityProvidersSamlAllOf
     */
    'sign_in_url': string;
}
/**
 * 
 * @export
 * @interface TenantProps
 */
export interface TenantProps {
    /**
     * tenant name
     * @type {string}
     * @memberof TenantProps
     */
    'name': string;
    /**
     * attribute info
     * @type {{ [key: string]: any; }}
     * @memberof TenantProps
     */
    'attributes': { [key: string]: any; };
    /**
     * administrative staff email address
     * @type {string}
     * @memberof TenantProps
     */
    'back_office_staff_email': string;
}
/**
 * Tenant Info
 * @export
 * @interface Tenants
 */
export interface Tenants {
    /**
     * 
     * @type {Array<Tenant>}
     * @memberof Tenants
     */
    'tenants': Array<Tenant>;
}
/**
 * 
 * @export
 * @interface UpdateBasicInfoParam
 */
export interface UpdateBasicInfoParam {
    /**
     * Domain Name
     * @type {string}
     * @memberof UpdateBasicInfoParam
     */
    'domain_name': string;
    /**
     * Sender email of authentication email
     * @type {string}
     * @memberof UpdateBasicInfoParam
     */
    'from_email_address': string;
    /**
     * Reply-from email address of authentication email
     * @type {string}
     * @memberof UpdateBasicInfoParam
     */
    'reply_email_address'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCustomizePageSettingsParam
 */
export interface UpdateCustomizePageSettingsParam {
    /**
     * service icon
     * @type {string}
     * @memberof UpdateCustomizePageSettingsParam
     */
    'icon': string;
    /**
     * favicon
     * @type {string}
     * @memberof UpdateCustomizePageSettingsParam
     */
    'favicon': string;
    /**
     * service name
     * @type {string}
     * @memberof UpdateCustomizePageSettingsParam
     */
    'title': string;
    /**
     * terms of service URL
     * @type {string}
     * @memberof UpdateCustomizePageSettingsParam
     */
    'terms_of_service_url': string;
    /**
     * privacy policy URL
     * @type {string}
     * @memberof UpdateCustomizePageSettingsParam
     */
    'privacy_policy_url': string;
    /**
     * Google Tag Manager container ID
     * @type {string}
     * @memberof UpdateCustomizePageSettingsParam
     */
    'google_tag_manager_container_id': string;
}
/**
 * 
 * @export
 * @interface UpdateCustomizePageSettingsParamAllOf
 */
export interface UpdateCustomizePageSettingsParamAllOf {
    /**
     * service icon
     * @type {string}
     * @memberof UpdateCustomizePageSettingsParamAllOf
     */
    'icon': string;
    /**
     * favicon
     * @type {string}
     * @memberof UpdateCustomizePageSettingsParamAllOf
     */
    'favicon': string;
}
/**
 * 
 * @export
 * @interface UpdateCustomizePagesParam
 */
export interface UpdateCustomizePagesParam {
    /**
     * 
     * @type {CustomizePageProps}
     * @memberof UpdateCustomizePagesParam
     */
    'sign_up_page'?: CustomizePageProps;
    /**
     * 
     * @type {CustomizePageProps}
     * @memberof UpdateCustomizePagesParam
     */
    'sign_in_page'?: CustomizePageProps;
    /**
     * 
     * @type {CustomizePageProps}
     * @memberof UpdateCustomizePagesParam
     */
    'password_reset_page'?: CustomizePageProps;
}
/**
 * 
 * @export
 * @interface UpdateEnvParam
 */
export interface UpdateEnvParam {
    /**
     * env name
     * @type {string}
     * @memberof UpdateEnvParam
     */
    'name': string;
    /**
     * env display name
     * @type {string}
     * @memberof UpdateEnvParam
     */
    'display_name'?: string;
}
/**
 * 
 * @export
 * @interface UpdateIdentityProviderParam
 */
export interface UpdateIdentityProviderParam {
    /**
     * 
     * @type {ProviderName}
     * @memberof UpdateIdentityProviderParam
     */
    'provider': ProviderName;
    /**
     * 
     * @type {IdentityProviderProps}
     * @memberof UpdateIdentityProviderParam
     */
    'identity_provider_props'?: IdentityProviderProps;
}
/**
 * 
 * @export
 * @interface UpdateNotificationMessagesParam
 */
export interface UpdateNotificationMessagesParam {
    /**
     * 
     * @type {MessageTemplate}
     * @memberof UpdateNotificationMessagesParam
     */
    'sign_up'?: MessageTemplate;
    /**
     * 
     * @type {MessageTemplate}
     * @memberof UpdateNotificationMessagesParam
     */
    'create_user'?: MessageTemplate;
    /**
     * 
     * @type {MessageTemplate}
     * @memberof UpdateNotificationMessagesParam
     */
    'resend_code'?: MessageTemplate;
    /**
     * 
     * @type {MessageTemplate}
     * @memberof UpdateNotificationMessagesParam
     */
    'forgot_password'?: MessageTemplate;
    /**
     * 
     * @type {MessageTemplate}
     * @memberof UpdateNotificationMessagesParam
     */
    'update_user_attribute'?: MessageTemplate;
    /**
     * 
     * @type {MessageTemplate}
     * @memberof UpdateNotificationMessagesParam
     */
    'verify_user_attribute'?: MessageTemplate;
    /**
     * 
     * @type {MessageTemplate}
     * @memberof UpdateNotificationMessagesParam
     */
    'authentication_mfa'?: MessageTemplate;
    /**
     * 
     * @type {MessageTemplate}
     * @memberof UpdateNotificationMessagesParam
     */
    'invite_tenant_user'?: MessageTemplate;
    /**
     * 
     * @type {MessageTemplate}
     * @memberof UpdateNotificationMessagesParam
     */
    'verify_external_user'?: MessageTemplate;
}
/**
 * 
 * @export
 * @interface UpdateSaasUserAttributesParam
 */
export interface UpdateSaasUserAttributesParam {
    /**
     * Attribute information 
     * @type {{ [key: string]: any; }}
     * @memberof UpdateSaasUserAttributesParam
     */
    'attributes': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface UpdateSaasUserEmailParam
 */
export interface UpdateSaasUserEmailParam {
    /**
     * E-mail
     * @type {string}
     * @memberof UpdateSaasUserEmailParam
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface UpdateSaasUserPasswordParam
 */
export interface UpdateSaasUserPasswordParam {
    /**
     * Password
     * @type {string}
     * @memberof UpdateSaasUserPasswordParam
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UpdateSignInSettingsParam
 */
export interface UpdateSignInSettingsParam {
    /**
     * 
     * @type {PasswordPolicy}
     * @memberof UpdateSignInSettingsParam
     */
    'password_policy'?: PasswordPolicy;
    /**
     * 
     * @type {DeviceConfiguration}
     * @memberof UpdateSignInSettingsParam
     */
    'device_configuration'?: DeviceConfiguration;
    /**
     * 
     * @type {MfaConfiguration}
     * @memberof UpdateSignInSettingsParam
     */
    'mfa_configuration'?: MfaConfiguration;
    /**
     * 
     * @type {RecaptchaProps}
     * @memberof UpdateSignInSettingsParam
     */
    'recaptcha_props'?: RecaptchaProps;
    /**
     * 
     * @type {AccountVerification}
     * @memberof UpdateSignInSettingsParam
     */
    'account_verification'?: AccountVerification;
    /**
     * 
     * @type {SelfRegist}
     * @memberof UpdateSignInSettingsParam
     */
    'self_regist'?: SelfRegist;
}
/**
 * 
 * @export
 * @interface UpdateSingleTenantSettingsParam
 */
export interface UpdateSingleTenantSettingsParam {
    /**
     * enable Single Tenant settings or not
     * @type {boolean}
     * @memberof UpdateSingleTenantSettingsParam
     */
    'enabled'?: boolean;
    /**
     * ARN of the role for SaaS Platform to AssumeRole
     * @type {string}
     * @memberof UpdateSingleTenantSettingsParam
     */
    'role_arn'?: string;
    /**
     * CloudFormation template file
     * @type {string}
     * @memberof UpdateSingleTenantSettingsParam
     */
    'cloudformation_template'?: string;
    /**
     * ddl file to run in SaaS environment
     * @type {string}
     * @memberof UpdateSingleTenantSettingsParam
     */
    'ddl_template'?: string;
    /**
     * External id used by SaaSus when AssumeRole to operate SaaS
     * @type {string}
     * @memberof UpdateSingleTenantSettingsParam
     */
    'role_external_id'?: string;
}
/**
 * 
 * @export
 * @interface UpdateSoftwareTokenParam
 */
export interface UpdateSoftwareTokenParam {
    /**
     * access token
     * @type {string}
     * @memberof UpdateSoftwareTokenParam
     */
    'access_token': string;
    /**
     * verification code
     * @type {string}
     * @memberof UpdateSoftwareTokenParam
     */
    'verification_code': string;
}
/**
 * If identity_provider_props is null, the sign-in information for the external identity provider specified in provider_type is disabled. 
 * @export
 * @interface UpdateTenantIdentityProviderParam
 */
export interface UpdateTenantIdentityProviderParam {
    /**
     * 
     * @type {ProviderType}
     * @memberof UpdateTenantIdentityProviderParam
     */
    'provider_type': ProviderType;
    /**
     * 
     * @type {TenantIdentityProviderProps}
     * @memberof UpdateTenantIdentityProviderParam
     */
    'identity_provider_props'?: TenantIdentityProviderProps;
}
/**
 * 
 * @export
 * @interface UpdateTenantUserParam
 */
export interface UpdateTenantUserParam {
    /**
     * Attribute information (Get information set by defining user attributes in the SaaS development console) 
     * @type {{ [key: string]: any; }}
     * @memberof UpdateTenantUserParam
     */
    'attributes': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * User ID
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'tenant_id': string;
    /**
     * Tenant Name
     * @type {string}
     * @memberof User
     */
    'tenant_name': string;
    /**
     * E-mail
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * Attribute information (Get information set by defining user attributes in the SaaS development console) 
     * @type {{ [key: string]: any; }}
     * @memberof User
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {Array<UserAvailableEnv>}
     * @memberof User
     */
    'envs': Array<UserAvailableEnv>;
}
/**
 * 
 * @export
 * @interface UserAttributes
 */
export interface UserAttributes {
    /**
     * User Attribute Definition
     * @type {Array<Attribute>}
     * @memberof UserAttributes
     */
    'user_attributes': Array<Attribute>;
}
/**
 * 
 * @export
 * @interface UserAvailableEnv
 */
export interface UserAvailableEnv {
    /**
     * 
     * @type {number}
     * @memberof UserAvailableEnv
     */
    'id': number;
    /**
     * env name
     * @type {string}
     * @memberof UserAvailableEnv
     */
    'name': string;
    /**
     * env display name
     * @type {string}
     * @memberof UserAvailableEnv
     */
    'display_name'?: string;
    /**
     * role info
     * @type {Array<Role>}
     * @memberof UserAvailableEnv
     */
    'roles': Array<Role>;
}
/**
 * 
 * @export
 * @interface UserAvailableTenant
 */
export interface UserAvailableTenant {
    /**
     * 
     * @type {string}
     * @memberof UserAvailableTenant
     */
    'id': string;
    /**
     * Tenant Name
     * @type {string}
     * @memberof UserAvailableTenant
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserAvailableTenant
     */
    'completed_sign_up': boolean;
    /**
     * environmental info, role info
     * @type {Array<UserAvailableEnv>}
     * @memberof UserAvailableTenant
     */
    'envs': Array<UserAvailableEnv>;
    /**
     * user additional attributes
     * @type {{ [key: string]: any; }}
     * @memberof UserAvailableTenant
     */
    'user_attribute': { [key: string]: any; };
    /**
     * back office contact email
     * @type {string}
     * @memberof UserAvailableTenant
     */
    'back_office_staff_email': string;
    /**
     * 
     * @type {string}
     * @memberof UserAvailableTenant
     */
    'plan_id'?: string;
    /**
     * tenant payment status ※ Currently, it is returned only when stripe is linked. 
     * @type {boolean}
     * @memberof UserAvailableTenant
     */
    'is_paid'?: boolean;
}
/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'id': string;
    /**
     * E-mail
     * @type {string}
     * @memberof UserInfo
     */
    'email': string;
    /**
     * user additional attributes
     * @type {{ [key: string]: any; }}
     * @memberof UserInfo
     */
    'user_attribute': { [key: string]: any; };
    /**
     * Tenant Info
     * @type {Array<UserAvailableTenant>}
     * @memberof UserInfo
     */
    'tenants': Array<UserAvailableTenant>;
}
/**
 * 
 * @export
 * @interface Users
 */
export interface Users {
    /**
     * 
     * @type {Array<User>}
     * @memberof Users
     */
    'users': Array<User>;
}
/**
 * Access token is required for existing users, and email and password is required for new users. 
 * @export
 * @interface ValidateInvitationParam
 */
export interface ValidateInvitationParam {
    /**
     * Access token of the invited user
     * @type {string}
     * @memberof ValidateInvitationParam
     */
    'access_token'?: string;
    /**
     * Email address of the invited user
     * @type {string}
     * @memberof ValidateInvitationParam
     */
    'email'?: string;
    /**
     * Password of the invited user
     * @type {string}
     * @memberof ValidateInvitationParam
     */
    'password'?: string;
}

/**
 * AuthInfoApi - axios parameter creator
 * @export
 */
export const AuthInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the post-login SaaS URL that contains authentication information. You can pass authentication information to the URL obtained here and implement this Callback using the SaaSus SDK. 
         * @summary Get Authentication Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sign-in information via external provider set in cognito. 
         * @summary Get Sign-In Information Via External Provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProviders: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity-providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user password requirements. Set a secure password that is difficult to decipher by increasing the number of digits by combining alphabets, numbers, and symbols. 
         * @summary Get Password Requirements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignInSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sign-in-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register post-login SaaS URL for authentication information. It is possible to pass authentication information to the URL registered here and implement this Callback using the SaaSus SDK. 
         * @summary Update Authentication Info
         * @param {AuthInfo} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAuthInfo: async (body?: AuthInfo, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the sign-in information for the external ID provider
         * @summary Update Sign-In Information
         * @param {UpdateIdentityProviderParam} [updateIdentityProviderParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIdentityProvider: async (updateIdentityProviderParam?: UpdateIdentityProviderParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity-providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateIdentityProviderParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user password requirements. Set a secure password that is difficult to decipher by increasing the number of digits by combining alphabets, numbers, and symbols. 
         * @summary Update Password Requirements
         * @param {UpdateSignInSettingsParam} [updateSignInSettingsParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSignInSettings: async (updateSignInSettingsParam?: UpdateSignInSettingsParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sign-in-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSignInSettingsParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthInfoApi - functional programming interface
 * @export
 */
export const AuthInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the post-login SaaS URL that contains authentication information. You can pass authentication information to the URL obtained here and implement this Callback using the SaaSus SDK. 
         * @summary Get Authentication Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get sign-in information via external provider set in cognito. 
         * @summary Get Sign-In Information Via External Provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIdentityProviders(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityProviders>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityProviders(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user password requirements. Set a secure password that is difficult to decipher by increasing the number of digits by combining alphabets, numbers, and symbols. 
         * @summary Get Password Requirements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignInSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignInSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register post-login SaaS URL for authentication information. It is possible to pass authentication information to the URL registered here and implement this Callback using the SaaSus SDK. 
         * @summary Update Authentication Info
         * @param {AuthInfo} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAuthInfo(body?: AuthInfo, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAuthInfo(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the sign-in information for the external ID provider
         * @summary Update Sign-In Information
         * @param {UpdateIdentityProviderParam} [updateIdentityProviderParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIdentityProvider(updateIdentityProviderParam?: UpdateIdentityProviderParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIdentityProvider(updateIdentityProviderParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user password requirements. Set a secure password that is difficult to decipher by increasing the number of digits by combining alphabets, numbers, and symbols. 
         * @summary Update Password Requirements
         * @param {UpdateSignInSettingsParam} [updateSignInSettingsParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSignInSettings(updateSignInSettingsParam?: UpdateSignInSettingsParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSignInSettings(updateSignInSettingsParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthInfoApi - factory interface
 * @export
 */
export const AuthInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthInfoApiFp(configuration)
    return {
        /**
         * Get the post-login SaaS URL that contains authentication information. You can pass authentication information to the URL obtained here and implement this Callback using the SaaSus SDK. 
         * @summary Get Authentication Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthInfo(options?: any): AxiosPromise<AuthInfo> {
            return localVarFp.getAuthInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Get sign-in information via external provider set in cognito. 
         * @summary Get Sign-In Information Via External Provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityProviders(options?: any): AxiosPromise<IdentityProviders> {
            return localVarFp.getIdentityProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * Get user password requirements. Set a secure password that is difficult to decipher by increasing the number of digits by combining alphabets, numbers, and symbols. 
         * @summary Get Password Requirements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignInSettings(options?: any): AxiosPromise<SignInSettings> {
            return localVarFp.getSignInSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Register post-login SaaS URL for authentication information. It is possible to pass authentication information to the URL registered here and implement this Callback using the SaaSus SDK. 
         * @summary Update Authentication Info
         * @param {AuthInfo} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAuthInfo(body?: AuthInfo, options?: any): AxiosPromise<void> {
            return localVarFp.updateAuthInfo(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the sign-in information for the external ID provider
         * @summary Update Sign-In Information
         * @param {UpdateIdentityProviderParam} [updateIdentityProviderParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIdentityProvider(updateIdentityProviderParam?: UpdateIdentityProviderParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateIdentityProvider(updateIdentityProviderParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user password requirements. Set a secure password that is difficult to decipher by increasing the number of digits by combining alphabets, numbers, and symbols. 
         * @summary Update Password Requirements
         * @param {UpdateSignInSettingsParam} [updateSignInSettingsParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSignInSettings(updateSignInSettingsParam?: UpdateSignInSettingsParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateSignInSettings(updateSignInSettingsParam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthInfoApi - object-oriented interface
 * @export
 * @class AuthInfoApi
 * @extends {BaseAPI}
 */
export class AuthInfoApi extends BaseAPI {
    /**
     * Get the post-login SaaS URL that contains authentication information. You can pass authentication information to the URL obtained here and implement this Callback using the SaaSus SDK. 
     * @summary Get Authentication Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthInfoApi
     */
    public getAuthInfo(options?: AxiosRequestConfig) {
        return AuthInfoApiFp(this.configuration).getAuthInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get sign-in information via external provider set in cognito. 
     * @summary Get Sign-In Information Via External Provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthInfoApi
     */
    public getIdentityProviders(options?: AxiosRequestConfig) {
        return AuthInfoApiFp(this.configuration).getIdentityProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user password requirements. Set a secure password that is difficult to decipher by increasing the number of digits by combining alphabets, numbers, and symbols. 
     * @summary Get Password Requirements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthInfoApi
     */
    public getSignInSettings(options?: AxiosRequestConfig) {
        return AuthInfoApiFp(this.configuration).getSignInSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register post-login SaaS URL for authentication information. It is possible to pass authentication information to the URL registered here and implement this Callback using the SaaSus SDK. 
     * @summary Update Authentication Info
     * @param {AuthInfo} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthInfoApi
     */
    public updateAuthInfo(body?: AuthInfo, options?: AxiosRequestConfig) {
        return AuthInfoApiFp(this.configuration).updateAuthInfo(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the sign-in information for the external ID provider
     * @summary Update Sign-In Information
     * @param {UpdateIdentityProviderParam} [updateIdentityProviderParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthInfoApi
     */
    public updateIdentityProvider(updateIdentityProviderParam?: UpdateIdentityProviderParam, options?: AxiosRequestConfig) {
        return AuthInfoApiFp(this.configuration).updateIdentityProvider(updateIdentityProviderParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user password requirements. Set a secure password that is difficult to decipher by increasing the number of digits by combining alphabets, numbers, and symbols. 
     * @summary Update Password Requirements
     * @param {UpdateSignInSettingsParam} [updateSignInSettingsParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthInfoApi
     */
    public updateSignInSettings(updateSignInSettingsParam?: UpdateSignInSettingsParam, options?: AxiosRequestConfig) {
        return AuthInfoApiFp(this.configuration).updateSignInSettings(updateSignInSettingsParam, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BasicInfoApi - axios parameter creator
 * @export
 */
export const BasicInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get notification email templates. 
         * @summary Get Notification Email Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findNotificationMessages: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notification-messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the domain name and CNAME record based on the SaaS ID. By setting the CNAME record on the DNS the login screen will be generated. 
         * @summary Get Basic Configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/basic-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get authentication authorization basic information. 
         * @summary Get Authentication Authorization Basic Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomizePageSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customize-page-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the authentication screen setting information (new registration, login, password reset, etc.). 
         * @summary Get Authentication Page Setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomizePages: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customize-pages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the domain name that was set as a parameter based on the SaaS ID. After the CNAME record is generated, set it in your DNS. If it is set on a SaaS application that is already running, it will affect the behavior. 
         * @summary Update Basic Configurations
         * @param {UpdateBasicInfoParam} [updateBasicInfoParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBasicInfo: async (updateBasicInfoParam?: UpdateBasicInfoParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/basic-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBasicInfoParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update authentication authorization basic information. 
         * @summary Update Authentication Authorization Basic Information
         * @param {UpdateCustomizePageSettingsParam} [updateCustomizePageSettingsParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomizePageSettings: async (updateCustomizePageSettingsParam?: UpdateCustomizePageSettingsParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customize-page-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomizePageSettingsParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the authentication page setting information (new registration, login, password reset, etc.). 
         * @summary Authentication Page Setting
         * @param {UpdateCustomizePagesParam} [updateCustomizePagesParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomizePages: async (updateCustomizePagesParam?: UpdateCustomizePagesParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customize-pages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomizePagesParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update notification email template. 
         * @summary Update Notification Email Template
         * @param {UpdateNotificationMessagesParam} [updateNotificationMessagesParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationMessages: async (updateNotificationMessagesParam?: UpdateNotificationMessagesParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notification-messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationMessagesParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasicInfoApi - functional programming interface
 * @export
 */
export const BasicInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BasicInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * Get notification email templates. 
         * @summary Get Notification Email Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findNotificationMessages(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationMessages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findNotificationMessages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the domain name and CNAME record based on the SaaS ID. By setting the CNAME record on the DNS the login screen will be generated. 
         * @summary Get Basic Configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBasicInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasicInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBasicInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get authentication authorization basic information. 
         * @summary Get Authentication Authorization Basic Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomizePageSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomizePageSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomizePageSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the authentication screen setting information (new registration, login, password reset, etc.). 
         * @summary Get Authentication Page Setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomizePages(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomizePages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomizePages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the domain name that was set as a parameter based on the SaaS ID. After the CNAME record is generated, set it in your DNS. If it is set on a SaaS application that is already running, it will affect the behavior. 
         * @summary Update Basic Configurations
         * @param {UpdateBasicInfoParam} [updateBasicInfoParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBasicInfo(updateBasicInfoParam?: UpdateBasicInfoParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBasicInfo(updateBasicInfoParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update authentication authorization basic information. 
         * @summary Update Authentication Authorization Basic Information
         * @param {UpdateCustomizePageSettingsParam} [updateCustomizePageSettingsParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomizePageSettings(updateCustomizePageSettingsParam?: UpdateCustomizePageSettingsParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomizePageSettings(updateCustomizePageSettingsParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the authentication page setting information (new registration, login, password reset, etc.). 
         * @summary Authentication Page Setting
         * @param {UpdateCustomizePagesParam} [updateCustomizePagesParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomizePages(updateCustomizePagesParam?: UpdateCustomizePagesParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomizePages(updateCustomizePagesParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update notification email template. 
         * @summary Update Notification Email Template
         * @param {UpdateNotificationMessagesParam} [updateNotificationMessagesParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotificationMessages(updateNotificationMessagesParam?: UpdateNotificationMessagesParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotificationMessages(updateNotificationMessagesParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BasicInfoApi - factory interface
 * @export
 */
export const BasicInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BasicInfoApiFp(configuration)
    return {
        /**
         * Get notification email templates. 
         * @summary Get Notification Email Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findNotificationMessages(options?: any): AxiosPromise<NotificationMessages> {
            return localVarFp.findNotificationMessages(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the domain name and CNAME record based on the SaaS ID. By setting the CNAME record on the DNS the login screen will be generated. 
         * @summary Get Basic Configurations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasicInfo(options?: any): AxiosPromise<BasicInfo> {
            return localVarFp.getBasicInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Get authentication authorization basic information. 
         * @summary Get Authentication Authorization Basic Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomizePageSettings(options?: any): AxiosPromise<CustomizePageSettings> {
            return localVarFp.getCustomizePageSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the authentication screen setting information (new registration, login, password reset, etc.). 
         * @summary Get Authentication Page Setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomizePages(options?: any): AxiosPromise<CustomizePages> {
            return localVarFp.getCustomizePages(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the domain name that was set as a parameter based on the SaaS ID. After the CNAME record is generated, set it in your DNS. If it is set on a SaaS application that is already running, it will affect the behavior. 
         * @summary Update Basic Configurations
         * @param {UpdateBasicInfoParam} [updateBasicInfoParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBasicInfo(updateBasicInfoParam?: UpdateBasicInfoParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateBasicInfo(updateBasicInfoParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Update authentication authorization basic information. 
         * @summary Update Authentication Authorization Basic Information
         * @param {UpdateCustomizePageSettingsParam} [updateCustomizePageSettingsParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomizePageSettings(updateCustomizePageSettingsParam?: UpdateCustomizePageSettingsParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateCustomizePageSettings(updateCustomizePageSettingsParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the authentication page setting information (new registration, login, password reset, etc.). 
         * @summary Authentication Page Setting
         * @param {UpdateCustomizePagesParam} [updateCustomizePagesParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomizePages(updateCustomizePagesParam?: UpdateCustomizePagesParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateCustomizePages(updateCustomizePagesParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Update notification email template. 
         * @summary Update Notification Email Template
         * @param {UpdateNotificationMessagesParam} [updateNotificationMessagesParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationMessages(updateNotificationMessagesParam?: UpdateNotificationMessagesParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateNotificationMessages(updateNotificationMessagesParam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BasicInfoApi - object-oriented interface
 * @export
 * @class BasicInfoApi
 * @extends {BaseAPI}
 */
export class BasicInfoApi extends BaseAPI {
    /**
     * Get notification email templates. 
     * @summary Get Notification Email Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicInfoApi
     */
    public findNotificationMessages(options?: AxiosRequestConfig) {
        return BasicInfoApiFp(this.configuration).findNotificationMessages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the domain name and CNAME record based on the SaaS ID. By setting the CNAME record on the DNS the login screen will be generated. 
     * @summary Get Basic Configurations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicInfoApi
     */
    public getBasicInfo(options?: AxiosRequestConfig) {
        return BasicInfoApiFp(this.configuration).getBasicInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get authentication authorization basic information. 
     * @summary Get Authentication Authorization Basic Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicInfoApi
     */
    public getCustomizePageSettings(options?: AxiosRequestConfig) {
        return BasicInfoApiFp(this.configuration).getCustomizePageSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the authentication screen setting information (new registration, login, password reset, etc.). 
     * @summary Get Authentication Page Setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicInfoApi
     */
    public getCustomizePages(options?: AxiosRequestConfig) {
        return BasicInfoApiFp(this.configuration).getCustomizePages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the domain name that was set as a parameter based on the SaaS ID. After the CNAME record is generated, set it in your DNS. If it is set on a SaaS application that is already running, it will affect the behavior. 
     * @summary Update Basic Configurations
     * @param {UpdateBasicInfoParam} [updateBasicInfoParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicInfoApi
     */
    public updateBasicInfo(updateBasicInfoParam?: UpdateBasicInfoParam, options?: AxiosRequestConfig) {
        return BasicInfoApiFp(this.configuration).updateBasicInfo(updateBasicInfoParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update authentication authorization basic information. 
     * @summary Update Authentication Authorization Basic Information
     * @param {UpdateCustomizePageSettingsParam} [updateCustomizePageSettingsParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicInfoApi
     */
    public updateCustomizePageSettings(updateCustomizePageSettingsParam?: UpdateCustomizePageSettingsParam, options?: AxiosRequestConfig) {
        return BasicInfoApiFp(this.configuration).updateCustomizePageSettings(updateCustomizePageSettingsParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the authentication page setting information (new registration, login, password reset, etc.). 
     * @summary Authentication Page Setting
     * @param {UpdateCustomizePagesParam} [updateCustomizePagesParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicInfoApi
     */
    public updateCustomizePages(updateCustomizePagesParam?: UpdateCustomizePagesParam, options?: AxiosRequestConfig) {
        return BasicInfoApiFp(this.configuration).updateCustomizePages(updateCustomizePagesParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update notification email template. 
     * @summary Update Notification Email Template
     * @param {UpdateNotificationMessagesParam} [updateNotificationMessagesParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicInfoApi
     */
    public updateNotificationMessages(updateNotificationMessagesParam?: UpdateNotificationMessagesParam, options?: AxiosRequestConfig) {
        return BasicInfoApiFp(this.configuration).updateNotificationMessages(updateNotificationMessagesParam, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CredentialApi - axios parameter creator
 * @export
 */
export const CredentialApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Temporarily save the parameter for the ID token, access token, and refresh token and return a temporary code for obtaining. Temporary codes are valid for 10 seconds from issuance. 
         * @summary Save Authentication/Authorization Information
         * @param {Credentials} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthCredentials: async (body?: Credentials, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get ID token, access token, and refresh token using a temporary code or a refresh token. 
         * @summary Get Authentication/Authorization Information
         * @param {string} [code] Temp Code
         * @param {'tempCodeAuth' | 'refreshTokenAuth'} [authFlow] Authentication Flow tempCodeAuth: Getting authentication information using a temporary code refreshTokenAuth: Getting authentication information using a refresh token If not specified, it will be tempCodeAuth 
         * @param {string} [refreshToken] Refresh Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthCredentials: async (code?: string, authFlow?: 'tempCodeAuth' | 'refreshTokenAuth', refreshToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (authFlow !== undefined) {
                localVarQueryParameter['auth-flow'] = authFlow;
            }

            if (refreshToken !== undefined) {
                localVarQueryParameter['refresh-token'] = refreshToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CredentialApi - functional programming interface
 * @export
 */
export const CredentialApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CredentialApiAxiosParamCreator(configuration)
    return {
        /**
         * Temporarily save the parameter for the ID token, access token, and refresh token and return a temporary code for obtaining. Temporary codes are valid for 10 seconds from issuance. 
         * @summary Save Authentication/Authorization Information
         * @param {Credentials} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthCredentials(body?: Credentials, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizationTempCode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthCredentials(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get ID token, access token, and refresh token using a temporary code or a refresh token. 
         * @summary Get Authentication/Authorization Information
         * @param {string} [code] Temp Code
         * @param {'tempCodeAuth' | 'refreshTokenAuth'} [authFlow] Authentication Flow tempCodeAuth: Getting authentication information using a temporary code refreshTokenAuth: Getting authentication information using a refresh token If not specified, it will be tempCodeAuth 
         * @param {string} [refreshToken] Refresh Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthCredentials(code?: string, authFlow?: 'tempCodeAuth' | 'refreshTokenAuth', refreshToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credentials>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthCredentials(code, authFlow, refreshToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CredentialApi - factory interface
 * @export
 */
export const CredentialApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CredentialApiFp(configuration)
    return {
        /**
         * Temporarily save the parameter for the ID token, access token, and refresh token and return a temporary code for obtaining. Temporary codes are valid for 10 seconds from issuance. 
         * @summary Save Authentication/Authorization Information
         * @param {Credentials} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthCredentials(body?: Credentials, options?: any): AxiosPromise<AuthorizationTempCode> {
            return localVarFp.createAuthCredentials(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get ID token, access token, and refresh token using a temporary code or a refresh token. 
         * @summary Get Authentication/Authorization Information
         * @param {string} [code] Temp Code
         * @param {'tempCodeAuth' | 'refreshTokenAuth'} [authFlow] Authentication Flow tempCodeAuth: Getting authentication information using a temporary code refreshTokenAuth: Getting authentication information using a refresh token If not specified, it will be tempCodeAuth 
         * @param {string} [refreshToken] Refresh Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthCredentials(code?: string, authFlow?: 'tempCodeAuth' | 'refreshTokenAuth', refreshToken?: string, options?: any): AxiosPromise<Credentials> {
            return localVarFp.getAuthCredentials(code, authFlow, refreshToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CredentialApi - object-oriented interface
 * @export
 * @class CredentialApi
 * @extends {BaseAPI}
 */
export class CredentialApi extends BaseAPI {
    /**
     * Temporarily save the parameter for the ID token, access token, and refresh token and return a temporary code for obtaining. Temporary codes are valid for 10 seconds from issuance. 
     * @summary Save Authentication/Authorization Information
     * @param {Credentials} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApi
     */
    public createAuthCredentials(body?: Credentials, options?: AxiosRequestConfig) {
        return CredentialApiFp(this.configuration).createAuthCredentials(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get ID token, access token, and refresh token using a temporary code or a refresh token. 
     * @summary Get Authentication/Authorization Information
     * @param {string} [code] Temp Code
     * @param {'tempCodeAuth' | 'refreshTokenAuth'} [authFlow] Authentication Flow tempCodeAuth: Getting authentication information using a temporary code refreshTokenAuth: Getting authentication information using a refresh token If not specified, it will be tempCodeAuth 
     * @param {string} [refreshToken] Refresh Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialApi
     */
    public getAuthCredentials(code?: string, authFlow?: 'tempCodeAuth' | 'refreshTokenAuth', refreshToken?: string, options?: AxiosRequestConfig) {
        return CredentialApiFp(this.configuration).getAuthCredentials(code, authFlow, refreshToken, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvApi - axios parameter creator
 * @export
 */
export const EnvApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create environment information. Multiple environments can be defined, such as an environment for testing linkage, an environment for development, and an environment for actual operation. 
         * @summary Create Env Info
         * @param {Env} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnv: async (body?: Env, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/envs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete env info. Env with id 3 cannot be deleted. 
         * @summary Delete Env Info
         * @param {number} envId Env ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnv: async (envId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('deleteEnv', 'envId', envId)
            const localVarPath = `/envs/{env_id}`
                .replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get environment details. 
         * @summary Get Env Details
         * @param {number} envId Env ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnv: async (envId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('getEnv', 'envId', envId)
            const localVarPath = `/envs/{env_id}`
                .replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get registered environment information. Multiple environments can be defined, such as an environment for testing linkage, an environment for development, and an environment for actual operation. 
         * @summary Get Env Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvs: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/envs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update env info. 
         * @summary Update Env Info
         * @param {number} envId Env ID
         * @param {UpdateEnvParam} [updateEnvParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnv: async (envId: number, updateEnvParam?: UpdateEnvParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('updateEnv', 'envId', envId)
            const localVarPath = `/envs/{env_id}`
                .replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEnvParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvApi - functional programming interface
 * @export
 */
export const EnvApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvApiAxiosParamCreator(configuration)
    return {
        /**
         * Create environment information. Multiple environments can be defined, such as an environment for testing linkage, an environment for development, and an environment for actual operation. 
         * @summary Create Env Info
         * @param {Env} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEnv(body?: Env, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Env>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEnv(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete env info. Env with id 3 cannot be deleted. 
         * @summary Delete Env Info
         * @param {number} envId Env ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnv(envId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEnv(envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get environment details. 
         * @summary Get Env Details
         * @param {number} envId Env ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnv(envId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Env>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnv(envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get registered environment information. Multiple environments can be defined, such as an environment for testing linkage, an environment for development, and an environment for actual operation. 
         * @summary Get Env Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvs(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Envs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update env info. 
         * @summary Update Env Info
         * @param {number} envId Env ID
         * @param {UpdateEnvParam} [updateEnvParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEnv(envId: number, updateEnvParam?: UpdateEnvParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEnv(envId, updateEnvParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EnvApi - factory interface
 * @export
 */
export const EnvApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvApiFp(configuration)
    return {
        /**
         * Create environment information. Multiple environments can be defined, such as an environment for testing linkage, an environment for development, and an environment for actual operation. 
         * @summary Create Env Info
         * @param {Env} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEnv(body?: Env, options?: any): AxiosPromise<Env> {
            return localVarFp.createEnv(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete env info. Env with id 3 cannot be deleted. 
         * @summary Delete Env Info
         * @param {number} envId Env ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnv(envId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEnv(envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get environment details. 
         * @summary Get Env Details
         * @param {number} envId Env ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnv(envId: number, options?: any): AxiosPromise<Env> {
            return localVarFp.getEnv(envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get registered environment information. Multiple environments can be defined, such as an environment for testing linkage, an environment for development, and an environment for actual operation. 
         * @summary Get Env Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvs(options?: any): AxiosPromise<Envs> {
            return localVarFp.getEnvs(options).then((request) => request(axios, basePath));
        },
        /**
         * Update env info. 
         * @summary Update Env Info
         * @param {number} envId Env ID
         * @param {UpdateEnvParam} [updateEnvParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEnv(envId: number, updateEnvParam?: UpdateEnvParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateEnv(envId, updateEnvParam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvApi - object-oriented interface
 * @export
 * @class EnvApi
 * @extends {BaseAPI}
 */
export class EnvApi extends BaseAPI {
    /**
     * Create environment information. Multiple environments can be defined, such as an environment for testing linkage, an environment for development, and an environment for actual operation. 
     * @summary Create Env Info
     * @param {Env} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvApi
     */
    public createEnv(body?: Env, options?: AxiosRequestConfig) {
        return EnvApiFp(this.configuration).createEnv(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete env info. Env with id 3 cannot be deleted. 
     * @summary Delete Env Info
     * @param {number} envId Env ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvApi
     */
    public deleteEnv(envId: number, options?: AxiosRequestConfig) {
        return EnvApiFp(this.configuration).deleteEnv(envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get environment details. 
     * @summary Get Env Details
     * @param {number} envId Env ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvApi
     */
    public getEnv(envId: number, options?: AxiosRequestConfig) {
        return EnvApiFp(this.configuration).getEnv(envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get registered environment information. Multiple environments can be defined, such as an environment for testing linkage, an environment for development, and an environment for actual operation. 
     * @summary Get Env Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvApi
     */
    public getEnvs(options?: AxiosRequestConfig) {
        return EnvApiFp(this.configuration).getEnvs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update env info. 
     * @summary Update Env Info
     * @param {number} envId Env ID
     * @param {UpdateEnvParam} [updateEnvParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvApi
     */
    public updateEnv(envId: number, updateEnvParam?: UpdateEnvParam, options?: AxiosRequestConfig) {
        return EnvApiFp(this.configuration).updateEnv(envId, updateEnvParam, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ErrorApi - axios parameter creator
 * @export
 */
export const ErrorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint is used for testing purposes. Returns a server error with status code 500. 
         * @summary Return Internal Server Error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnInternalServerError: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/errors/internal-server-error`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ErrorApi - functional programming interface
 * @export
 */
export const ErrorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ErrorApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint is used for testing purposes. Returns a server error with status code 500. 
         * @summary Return Internal Server Error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async returnInternalServerError(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.returnInternalServerError(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ErrorApi - factory interface
 * @export
 */
export const ErrorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ErrorApiFp(configuration)
    return {
        /**
         * This endpoint is used for testing purposes. Returns a server error with status code 500. 
         * @summary Return Internal Server Error
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnInternalServerError(options?: any): AxiosPromise<void> {
            return localVarFp.returnInternalServerError(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ErrorApi - object-oriented interface
 * @export
 * @class ErrorApi
 * @extends {BaseAPI}
 */
export class ErrorApi extends BaseAPI {
    /**
     * This endpoint is used for testing purposes. Returns a server error with status code 500. 
     * @summary Return Internal Server Error
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorApi
     */
    public returnInternalServerError(options?: AxiosRequestConfig) {
        return ErrorApiFp(this.configuration).returnInternalServerError(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvitationApi - axios parameter creator
 * @export
 */
export const InvitationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an invitation to the tenant. 
         * @summary Create Tenant Invitation
         * @param {string} tenantId Tenant ID
         * @param {CreateTenantInvitationParam} [createTenantInvitationParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenantInvitation: async (tenantId: string, createTenantInvitationParam?: CreateTenantInvitationParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('createTenantInvitation', 'tenantId', tenantId)
            const localVarPath = `/tenants/{tenant_id}/invitations`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTenantInvitationParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an invitation for the tenant. 
         * @summary Delete Tenant Invitation
         * @param {string} tenantId Tenant ID
         * @param {string} invitationId Invitation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenantInvitation: async (tenantId: string, invitationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('deleteTenantInvitation', 'tenantId', tenantId)
            // verify required parameter 'invitationId' is not null or undefined
            assertParamExists('deleteTenantInvitation', 'invitationId', invitationId)
            const localVarPath = `/tenants/{tenant_id}/invitations/{invitation_id}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"invitation_id"}}`, encodeURIComponent(String(invitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the validity of an invitation to the tenant. 
         * @summary Get Invitation Validity
         * @param {string} invitationId Invitation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitationValidity: async (invitationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invitationId' is not null or undefined
            assertParamExists('getInvitationValidity', 'invitationId', invitationId)
            const localVarPath = `/invitations/{invitation_id}/validity`
                .replace(`{${"invitation_id"}}`, encodeURIComponent(String(invitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get invitation information for the tenant. 
         * @summary Get Tenant Invitation
         * @param {string} tenantId Tenant ID
         * @param {string} invitationId Invitation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantInvitation: async (tenantId: string, invitationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getTenantInvitation', 'tenantId', tenantId)
            // verify required parameter 'invitationId' is not null or undefined
            assertParamExists('getTenantInvitation', 'invitationId', invitationId)
            const localVarPath = `/tenants/{tenant_id}/invitations/{invitation_id}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"invitation_id"}}`, encodeURIComponent(String(invitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of invitations to the tenant. 
         * @summary Get Tenant Invitations
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantInvitations: async (tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getTenantInvitations', 'tenantId', tenantId)
            const localVarPath = `/tenants/{tenant_id}/invitations`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate an invitation to the tenant. 
         * @summary Validate Invitation
         * @param {string} invitationId Invitation ID
         * @param {ValidateInvitationParam} [validateInvitationParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateInvitation: async (invitationId: string, validateInvitationParam?: ValidateInvitationParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invitationId' is not null or undefined
            assertParamExists('validateInvitation', 'invitationId', invitationId)
            const localVarPath = `/invitations/{invitation_id}/validate`
                .replace(`{${"invitation_id"}}`, encodeURIComponent(String(invitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validateInvitationParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitationApi - functional programming interface
 * @export
 */
export const InvitationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvitationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an invitation to the tenant. 
         * @summary Create Tenant Invitation
         * @param {string} tenantId Tenant ID
         * @param {CreateTenantInvitationParam} [createTenantInvitationParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTenantInvitation(tenantId: string, createTenantInvitationParam?: CreateTenantInvitationParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTenantInvitation(tenantId, createTenantInvitationParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an invitation for the tenant. 
         * @summary Delete Tenant Invitation
         * @param {string} tenantId Tenant ID
         * @param {string} invitationId Invitation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTenantInvitation(tenantId: string, invitationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTenantInvitation(tenantId, invitationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the validity of an invitation to the tenant. 
         * @summary Get Invitation Validity
         * @param {string} invitationId Invitation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvitationValidity(invitationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvitationValidity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvitationValidity(invitationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get invitation information for the tenant. 
         * @summary Get Tenant Invitation
         * @param {string} tenantId Tenant ID
         * @param {string} invitationId Invitation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTenantInvitation(tenantId: string, invitationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTenantInvitation(tenantId, invitationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of invitations to the tenant. 
         * @summary Get Tenant Invitations
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTenantInvitations(tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invitations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTenantInvitations(tenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validate an invitation to the tenant. 
         * @summary Validate Invitation
         * @param {string} invitationId Invitation ID
         * @param {ValidateInvitationParam} [validateInvitationParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateInvitation(invitationId: string, validateInvitationParam?: ValidateInvitationParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateInvitation(invitationId, validateInvitationParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvitationApi - factory interface
 * @export
 */
export const InvitationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvitationApiFp(configuration)
    return {
        /**
         * Create an invitation to the tenant. 
         * @summary Create Tenant Invitation
         * @param {string} tenantId Tenant ID
         * @param {CreateTenantInvitationParam} [createTenantInvitationParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenantInvitation(tenantId: string, createTenantInvitationParam?: CreateTenantInvitationParam, options?: any): AxiosPromise<Invitation> {
            return localVarFp.createTenantInvitation(tenantId, createTenantInvitationParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an invitation for the tenant. 
         * @summary Delete Tenant Invitation
         * @param {string} tenantId Tenant ID
         * @param {string} invitationId Invitation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenantInvitation(tenantId: string, invitationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTenantInvitation(tenantId, invitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the validity of an invitation to the tenant. 
         * @summary Get Invitation Validity
         * @param {string} invitationId Invitation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitationValidity(invitationId: string, options?: any): AxiosPromise<InvitationValidity> {
            return localVarFp.getInvitationValidity(invitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get invitation information for the tenant. 
         * @summary Get Tenant Invitation
         * @param {string} tenantId Tenant ID
         * @param {string} invitationId Invitation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantInvitation(tenantId: string, invitationId: string, options?: any): AxiosPromise<Invitation> {
            return localVarFp.getTenantInvitation(tenantId, invitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of invitations to the tenant. 
         * @summary Get Tenant Invitations
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantInvitations(tenantId: string, options?: any): AxiosPromise<Invitations> {
            return localVarFp.getTenantInvitations(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate an invitation to the tenant. 
         * @summary Validate Invitation
         * @param {string} invitationId Invitation ID
         * @param {ValidateInvitationParam} [validateInvitationParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateInvitation(invitationId: string, validateInvitationParam?: ValidateInvitationParam, options?: any): AxiosPromise<void> {
            return localVarFp.validateInvitation(invitationId, validateInvitationParam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvitationApi - object-oriented interface
 * @export
 * @class InvitationApi
 * @extends {BaseAPI}
 */
export class InvitationApi extends BaseAPI {
    /**
     * Create an invitation to the tenant. 
     * @summary Create Tenant Invitation
     * @param {string} tenantId Tenant ID
     * @param {CreateTenantInvitationParam} [createTenantInvitationParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public createTenantInvitation(tenantId: string, createTenantInvitationParam?: CreateTenantInvitationParam, options?: AxiosRequestConfig) {
        return InvitationApiFp(this.configuration).createTenantInvitation(tenantId, createTenantInvitationParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an invitation for the tenant. 
     * @summary Delete Tenant Invitation
     * @param {string} tenantId Tenant ID
     * @param {string} invitationId Invitation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public deleteTenantInvitation(tenantId: string, invitationId: string, options?: AxiosRequestConfig) {
        return InvitationApiFp(this.configuration).deleteTenantInvitation(tenantId, invitationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the validity of an invitation to the tenant. 
     * @summary Get Invitation Validity
     * @param {string} invitationId Invitation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public getInvitationValidity(invitationId: string, options?: AxiosRequestConfig) {
        return InvitationApiFp(this.configuration).getInvitationValidity(invitationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get invitation information for the tenant. 
     * @summary Get Tenant Invitation
     * @param {string} tenantId Tenant ID
     * @param {string} invitationId Invitation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public getTenantInvitation(tenantId: string, invitationId: string, options?: AxiosRequestConfig) {
        return InvitationApiFp(this.configuration).getTenantInvitation(tenantId, invitationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of invitations to the tenant. 
     * @summary Get Tenant Invitations
     * @param {string} tenantId Tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public getTenantInvitations(tenantId: string, options?: AxiosRequestConfig) {
        return InvitationApiFp(this.configuration).getTenantInvitations(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate an invitation to the tenant. 
     * @summary Validate Invitation
     * @param {string} invitationId Invitation ID
     * @param {ValidateInvitationParam} [validateInvitationParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public validateInvitation(invitationId: string, validateInvitationParam?: ValidateInvitationParam, options?: AxiosRequestConfig) {
        return InvitationApiFp(this.configuration).validateInvitation(invitationId, validateInvitationParam, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RoleApi - axios parameter creator
 * @export
 */
export const RoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a role. By granting users the roles created here, it becomes easier to implement role-based authorization on the SaaS side. In addition, even the same user can have different roles for each tenant/environment to which they belong. 
         * @summary Create Role
         * @param {Role} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (body?: Role, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete role. 
         * @summary Delete Role
         * @param {string} roleName Role name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (roleName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleName' is not null or undefined
            assertParamExists('deleteRole', 'roleName', roleName)
            const localVarPath = `/roles/{role_name}`
                .replace(`{${"role_name"}}`, encodeURIComponent(String(roleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get registered roles list. Granting users the roles defined here makes it easy to implement role-based authorization on the SaaS side. In addition, even the same user can have different roles for each tenant/environment to which they belong. 
         * @summary Get Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleApi - functional programming interface
 * @export
 */
export const RoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoleApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a role. By granting users the roles created here, it becomes easier to implement role-based authorization on the SaaS side. In addition, even the same user can have different roles for each tenant/environment to which they belong. 
         * @summary Create Role
         * @param {Role} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(body?: Role, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete role. 
         * @summary Delete Role
         * @param {string} roleName Role name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(roleName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(roleName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get registered roles list. Granting users the roles defined here makes it easy to implement role-based authorization on the SaaS side. In addition, even the same user can have different roles for each tenant/environment to which they belong. 
         * @summary Get Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoles(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Roles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RoleApi - factory interface
 * @export
 */
export const RoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoleApiFp(configuration)
    return {
        /**
         * Create a role. By granting users the roles created here, it becomes easier to implement role-based authorization on the SaaS side. In addition, even the same user can have different roles for each tenant/environment to which they belong. 
         * @summary Create Role
         * @param {Role} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(body?: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.createRole(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete role. 
         * @summary Delete Role
         * @param {string} roleName Role name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(roleName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRole(roleName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get registered roles list. Granting users the roles defined here makes it easy to implement role-based authorization on the SaaS side. In addition, even the same user can have different roles for each tenant/environment to which they belong. 
         * @summary Get Roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(options?: any): AxiosPromise<Roles> {
            return localVarFp.getRoles(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoleApi - object-oriented interface
 * @export
 * @class RoleApi
 * @extends {BaseAPI}
 */
export class RoleApi extends BaseAPI {
    /**
     * Create a role. By granting users the roles created here, it becomes easier to implement role-based authorization on the SaaS side. In addition, even the same user can have different roles for each tenant/environment to which they belong. 
     * @summary Create Role
     * @param {Role} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public createRole(body?: Role, options?: AxiosRequestConfig) {
        return RoleApiFp(this.configuration).createRole(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete role. 
     * @summary Delete Role
     * @param {string} roleName Role name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public deleteRole(roleName: string, options?: AxiosRequestConfig) {
        return RoleApiFp(this.configuration).deleteRole(roleName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get registered roles list. Granting users the roles defined here makes it easy to implement role-based authorization on the SaaS side. In addition, even the same user can have different roles for each tenant/environment to which they belong. 
     * @summary Get Roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public getRoles(options?: AxiosRequestConfig) {
        return RoleApiFp(this.configuration).getRoles(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SaasUserApi - axios parameter creator
 * @export
 */
export const SaasUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Verify the code to confirm the user\'s email address update. Requires the user\'s access token. 
         * @summary Confirm User Email Update
         * @param {string} userId User ID
         * @param {ConfirmEmailUpdateParam} [confirmEmailUpdateParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmailUpdate: async (userId: string, confirmEmailUpdateParam?: ConfirmEmailUpdateParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('confirmEmailUpdate', 'userId', userId)
            const localVarPath = `/users/{user_id}/email/confirm`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmEmailUpdateParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify the code for external account user link confirmation. 
         * @summary Confirm External User Account Link
         * @param {ConfirmExternalUserLinkParam} [confirmExternalUserLinkParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmExternalUserLink: async (confirmExternalUserLinkParam?: ConfirmExternalUserLinkParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/external-users/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmExternalUserLinkParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirm a new use registeration linked to AWS Marketplace. Create a new tenant linked to AWS Marketplace. If the Registration Token is not valid, an error is returned. 
         * @summary Confirm Sign Up with AWS Marketplace
         * @param {ConfirmSignUpWithAwsMarketplaceParam} [confirmSignUpWithAwsMarketplaceParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmSignUpWithAwsMarketplace: async (confirmSignUpWithAwsMarketplaceParam?: ConfirmSignUpWithAwsMarketplaceParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aws-marketplace/sign-up-confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmSignUpWithAwsMarketplaceParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create SaaS User. If attributes is empty, a temporary password will be sent to the registered email. 
         * @summary Create SaaS User
         * @param {CreateSaasUserParam} [createSaasUserParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSaasUser: async (createSaasUserParam?: CreateSaasUserParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSaasUserParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a secret code for authentication application registration. 
         * @summary Create secret code for authentication application registration
         * @param {string} userId User ID
         * @param {CreateSecretCodeParam} [createSecretCodeParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecretCode: async (userId: string, createSecretCodeParam?: CreateSecretCodeParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createSecretCode', 'userId', userId)
            const localVarPath = `/users/{user_id}/mfa/software-token/secret-code`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSecretCodeParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all users with matching user ID from the tenant and SaaS. 
         * @summary Delete User
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSaasUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteSaasUser', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user information based on user ID. 
         * @summary Get User
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSaasUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getSaasUser', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all SaaS users. 
         * @summary Get Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSaasUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user\'s MFA settings. 
         * @summary Get User\'s MFA Settings
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserMfaPreference: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserMfaPreference', 'userId', userId)
            const localVarPath = `/users/{user_id}/mfa/preference`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Link an existing tenant with AWS Marketplace. If the Registration Token is not valid, an error is returned. 
         * @summary Link an existing tenant with AWS Marketplace
         * @param {LinkAwsMarketplaceParam} [linkAwsMarketplaceParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAwsMarketplace: async (linkAwsMarketplaceParam?: LinkAwsMarketplaceParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aws-marketplace/link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(linkAwsMarketplaceParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request to update the user\'s email address. Sends a verification code to the requested email address. Requires the user\'s access token. The verification code is valid for 24 hours. 
         * @summary Request User Email Update
         * @param {string} userId User ID
         * @param {RequestEmailUpdateParam} [requestEmailUpdateParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestEmailUpdate: async (userId: string, requestEmailUpdateParam?: RequestEmailUpdateParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('requestEmailUpdate', 'userId', userId)
            const localVarPath = `/users/{user_id}/email/request`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestEmailUpdateParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request to link an external account user. Get the email address of the user to be linked from the access token and send a verification code to that email address. The verification code is valid for 24 hours. 
         * @summary Request External User Account Link
         * @param {RequestExternalUserLinkParam} [requestExternalUserLinkParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestExternalUserLink: async (requestExternalUserLinkParam?: RequestExternalUserLinkParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/external-users/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestExternalUserLinkParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend temporary password for the new registered user. 
         * @summary Resend Sign Up Confirmation Email
         * @param {ResendSignUpConfirmationEmailParam} [resendSignUpConfirmationEmailParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendSignUpConfirmationEmail: async (resendSignUpConfirmationEmailParam?: ResendSignUpConfirmationEmailParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sign-up/resend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resendSignUpConfirmationEmailParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new user. A temporary password will be sent to the registered email. 
         * @summary Sign Up
         * @param {SignUpParam} [signUpParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp: async (signUpParam?: SignUpParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new user linked to AWS Marketplace. A temporary password will be sent to the registered email. If the Registration Token is not valid, an error is returned. 
         * @summary Sign Up with AWS Marketplace
         * @param {SignUpWithAwsMarketplaceParam} [signUpWithAwsMarketplaceParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpWithAwsMarketplace: async (signUpWithAwsMarketplaceParam?: SignUpWithAwsMarketplaceParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/aws-marketplace/sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpWithAwsMarketplaceParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlink external identity providers. 
         * @summary Unlink external identity providers
         * @param {string} providerName 
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkProvider: async (providerName: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerName' is not null or undefined
            assertParamExists('unlinkProvider', 'providerName', providerName)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('unlinkProvider', 'userId', userId)
            const localVarPath = `/users/{user_id}/providers/{provider_name}`
                .replace(`{${"provider_name"}}`, encodeURIComponent(String(providerName)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the additional attributes of the SaaS user. 
         * @summary Update SaaS User Attributes
         * @param {string} userId User ID
         * @param {UpdateSaasUserAttributesParam} [updateSaasUserAttributesParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSaasUserAttributes: async (userId: string, updateSaasUserAttributesParam?: UpdateSaasUserAttributesParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateSaasUserAttributes', 'userId', userId)
            const localVarPath = `/users/{user_id}/attributes`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSaasUserAttributesParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s email. 
         * @summary Change Email
         * @param {string} userId User ID
         * @param {UpdateSaasUserEmailParam} [updateSaasUserEmailParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSaasUserEmail: async (userId: string, updateSaasUserEmailParam?: UpdateSaasUserEmailParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateSaasUserEmail', 'userId', userId)
            const localVarPath = `/users/{user_id}/email`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSaasUserEmailParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change user\'s login password. 
         * @summary Change Password
         * @param {string} userId User ID
         * @param {UpdateSaasUserPasswordParam} [updateSaasUserPasswordParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSaasUserPassword: async (userId: string, updateSaasUserPasswordParam?: UpdateSaasUserPasswordParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateSaasUserPassword', 'userId', userId)
            const localVarPath = `/users/{user_id}/password`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSaasUserPasswordParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register an authentication application. 
         * @summary Register Authentication Application
         * @param {string} userId User ID
         * @param {UpdateSoftwareTokenParam} [updateSoftwareTokenParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSoftwareToken: async (userId: string, updateSoftwareTokenParam?: UpdateSoftwareTokenParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateSoftwareToken', 'userId', userId)
            const localVarPath = `/users/{user_id}/mfa/software-token`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSoftwareTokenParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user\'s MFA settings. 
         * @summary Update User\'s MFA Settings
         * @param {string} userId User ID
         * @param {MfaPreference} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserMfaPreference: async (userId: string, body?: MfaPreference, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserMfaPreference', 'userId', userId)
            const localVarPath = `/users/{user_id}/mfa/preference`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SaasUserApi - functional programming interface
 * @export
 */
export const SaasUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SaasUserApiAxiosParamCreator(configuration)
    return {
        /**
         * Verify the code to confirm the user\'s email address update. Requires the user\'s access token. 
         * @summary Confirm User Email Update
         * @param {string} userId User ID
         * @param {ConfirmEmailUpdateParam} [confirmEmailUpdateParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmEmailUpdate(userId: string, confirmEmailUpdateParam?: ConfirmEmailUpdateParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmEmailUpdate(userId, confirmEmailUpdateParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verify the code for external account user link confirmation. 
         * @summary Confirm External User Account Link
         * @param {ConfirmExternalUserLinkParam} [confirmExternalUserLinkParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmExternalUserLink(confirmExternalUserLinkParam?: ConfirmExternalUserLinkParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmExternalUserLink(confirmExternalUserLinkParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Confirm a new use registeration linked to AWS Marketplace. Create a new tenant linked to AWS Marketplace. If the Registration Token is not valid, an error is returned. 
         * @summary Confirm Sign Up with AWS Marketplace
         * @param {ConfirmSignUpWithAwsMarketplaceParam} [confirmSignUpWithAwsMarketplaceParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmSignUpWithAwsMarketplace(confirmSignUpWithAwsMarketplaceParam?: ConfirmSignUpWithAwsMarketplaceParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmSignUpWithAwsMarketplace(confirmSignUpWithAwsMarketplaceParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create SaaS User. If attributes is empty, a temporary password will be sent to the registered email. 
         * @summary Create SaaS User
         * @param {CreateSaasUserParam} [createSaasUserParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSaasUser(createSaasUserParam?: CreateSaasUserParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaasUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSaasUser(createSaasUserParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a secret code for authentication application registration. 
         * @summary Create secret code for authentication application registration
         * @param {string} userId User ID
         * @param {CreateSecretCodeParam} [createSecretCodeParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSecretCode(userId: string, createSecretCodeParam?: CreateSecretCodeParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoftwareTokenSecretCode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSecretCode(userId, createSecretCodeParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete all users with matching user ID from the tenant and SaaS. 
         * @summary Delete User
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSaasUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSaasUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user information based on user ID. 
         * @summary Get User
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSaasUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaasUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSaasUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all SaaS users. 
         * @summary Get Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSaasUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaasUsers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSaasUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the user\'s MFA settings. 
         * @summary Get User\'s MFA Settings
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserMfaPreference(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MfaPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserMfaPreference(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Link an existing tenant with AWS Marketplace. If the Registration Token is not valid, an error is returned. 
         * @summary Link an existing tenant with AWS Marketplace
         * @param {LinkAwsMarketplaceParam} [linkAwsMarketplaceParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkAwsMarketplace(linkAwsMarketplaceParam?: LinkAwsMarketplaceParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkAwsMarketplace(linkAwsMarketplaceParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Request to update the user\'s email address. Sends a verification code to the requested email address. Requires the user\'s access token. The verification code is valid for 24 hours. 
         * @summary Request User Email Update
         * @param {string} userId User ID
         * @param {RequestEmailUpdateParam} [requestEmailUpdateParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestEmailUpdate(userId: string, requestEmailUpdateParam?: RequestEmailUpdateParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestEmailUpdate(userId, requestEmailUpdateParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Request to link an external account user. Get the email address of the user to be linked from the access token and send a verification code to that email address. The verification code is valid for 24 hours. 
         * @summary Request External User Account Link
         * @param {RequestExternalUserLinkParam} [requestExternalUserLinkParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestExternalUserLink(requestExternalUserLinkParam?: RequestExternalUserLinkParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestExternalUserLink(requestExternalUserLinkParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resend temporary password for the new registered user. 
         * @summary Resend Sign Up Confirmation Email
         * @param {ResendSignUpConfirmationEmailParam} [resendSignUpConfirmationEmailParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendSignUpConfirmationEmail(resendSignUpConfirmationEmailParam?: ResendSignUpConfirmationEmailParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendSignUpConfirmationEmail(resendSignUpConfirmationEmailParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register a new user. A temporary password will be sent to the registered email. 
         * @summary Sign Up
         * @param {SignUpParam} [signUpParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUp(signUpParam?: SignUpParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaasUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signUp(signUpParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register a new user linked to AWS Marketplace. A temporary password will be sent to the registered email. If the Registration Token is not valid, an error is returned. 
         * @summary Sign Up with AWS Marketplace
         * @param {SignUpWithAwsMarketplaceParam} [signUpWithAwsMarketplaceParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUpWithAwsMarketplace(signUpWithAwsMarketplaceParam?: SignUpWithAwsMarketplaceParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaasUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signUpWithAwsMarketplace(signUpWithAwsMarketplaceParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unlink external identity providers. 
         * @summary Unlink external identity providers
         * @param {string} providerName 
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkProvider(providerName: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkProvider(providerName, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the additional attributes of the SaaS user. 
         * @summary Update SaaS User Attributes
         * @param {string} userId User ID
         * @param {UpdateSaasUserAttributesParam} [updateSaasUserAttributesParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSaasUserAttributes(userId: string, updateSaasUserAttributesParam?: UpdateSaasUserAttributesParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSaasUserAttributes(userId, updateSaasUserAttributesParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change user\'s email. 
         * @summary Change Email
         * @param {string} userId User ID
         * @param {UpdateSaasUserEmailParam} [updateSaasUserEmailParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSaasUserEmail(userId: string, updateSaasUserEmailParam?: UpdateSaasUserEmailParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSaasUserEmail(userId, updateSaasUserEmailParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change user\'s login password. 
         * @summary Change Password
         * @param {string} userId User ID
         * @param {UpdateSaasUserPasswordParam} [updateSaasUserPasswordParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSaasUserPassword(userId: string, updateSaasUserPasswordParam?: UpdateSaasUserPasswordParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSaasUserPassword(userId, updateSaasUserPasswordParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register an authentication application. 
         * @summary Register Authentication Application
         * @param {string} userId User ID
         * @param {UpdateSoftwareTokenParam} [updateSoftwareTokenParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSoftwareToken(userId: string, updateSoftwareTokenParam?: UpdateSoftwareTokenParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSoftwareToken(userId, updateSoftwareTokenParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user\'s MFA settings. 
         * @summary Update User\'s MFA Settings
         * @param {string} userId User ID
         * @param {MfaPreference} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserMfaPreference(userId: string, body?: MfaPreference, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserMfaPreference(userId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SaasUserApi - factory interface
 * @export
 */
export const SaasUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SaasUserApiFp(configuration)
    return {
        /**
         * Verify the code to confirm the user\'s email address update. Requires the user\'s access token. 
         * @summary Confirm User Email Update
         * @param {string} userId User ID
         * @param {ConfirmEmailUpdateParam} [confirmEmailUpdateParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmailUpdate(userId: string, confirmEmailUpdateParam?: ConfirmEmailUpdateParam, options?: any): AxiosPromise<void> {
            return localVarFp.confirmEmailUpdate(userId, confirmEmailUpdateParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify the code for external account user link confirmation. 
         * @summary Confirm External User Account Link
         * @param {ConfirmExternalUserLinkParam} [confirmExternalUserLinkParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmExternalUserLink(confirmExternalUserLinkParam?: ConfirmExternalUserLinkParam, options?: any): AxiosPromise<void> {
            return localVarFp.confirmExternalUserLink(confirmExternalUserLinkParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirm a new use registeration linked to AWS Marketplace. Create a new tenant linked to AWS Marketplace. If the Registration Token is not valid, an error is returned. 
         * @summary Confirm Sign Up with AWS Marketplace
         * @param {ConfirmSignUpWithAwsMarketplaceParam} [confirmSignUpWithAwsMarketplaceParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmSignUpWithAwsMarketplace(confirmSignUpWithAwsMarketplaceParam?: ConfirmSignUpWithAwsMarketplaceParam, options?: any): AxiosPromise<Tenant> {
            return localVarFp.confirmSignUpWithAwsMarketplace(confirmSignUpWithAwsMarketplaceParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Create SaaS User. If attributes is empty, a temporary password will be sent to the registered email. 
         * @summary Create SaaS User
         * @param {CreateSaasUserParam} [createSaasUserParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSaasUser(createSaasUserParam?: CreateSaasUserParam, options?: any): AxiosPromise<SaasUser> {
            return localVarFp.createSaasUser(createSaasUserParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a secret code for authentication application registration. 
         * @summary Create secret code for authentication application registration
         * @param {string} userId User ID
         * @param {CreateSecretCodeParam} [createSecretCodeParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecretCode(userId: string, createSecretCodeParam?: CreateSecretCodeParam, options?: any): AxiosPromise<SoftwareTokenSecretCode> {
            return localVarFp.createSecretCode(userId, createSecretCodeParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all users with matching user ID from the tenant and SaaS. 
         * @summary Delete User
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSaasUser(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSaasUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user information based on user ID. 
         * @summary Get User
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSaasUser(userId: string, options?: any): AxiosPromise<SaasUser> {
            return localVarFp.getSaasUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all SaaS users. 
         * @summary Get Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSaasUsers(options?: any): AxiosPromise<SaasUsers> {
            return localVarFp.getSaasUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user\'s MFA settings. 
         * @summary Get User\'s MFA Settings
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserMfaPreference(userId: string, options?: any): AxiosPromise<MfaPreference> {
            return localVarFp.getUserMfaPreference(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Link an existing tenant with AWS Marketplace. If the Registration Token is not valid, an error is returned. 
         * @summary Link an existing tenant with AWS Marketplace
         * @param {LinkAwsMarketplaceParam} [linkAwsMarketplaceParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAwsMarketplace(linkAwsMarketplaceParam?: LinkAwsMarketplaceParam, options?: any): AxiosPromise<void> {
            return localVarFp.linkAwsMarketplace(linkAwsMarketplaceParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Request to update the user\'s email address. Sends a verification code to the requested email address. Requires the user\'s access token. The verification code is valid for 24 hours. 
         * @summary Request User Email Update
         * @param {string} userId User ID
         * @param {RequestEmailUpdateParam} [requestEmailUpdateParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestEmailUpdate(userId: string, requestEmailUpdateParam?: RequestEmailUpdateParam, options?: any): AxiosPromise<void> {
            return localVarFp.requestEmailUpdate(userId, requestEmailUpdateParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Request to link an external account user. Get the email address of the user to be linked from the access token and send a verification code to that email address. The verification code is valid for 24 hours. 
         * @summary Request External User Account Link
         * @param {RequestExternalUserLinkParam} [requestExternalUserLinkParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestExternalUserLink(requestExternalUserLinkParam?: RequestExternalUserLinkParam, options?: any): AxiosPromise<void> {
            return localVarFp.requestExternalUserLink(requestExternalUserLinkParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend temporary password for the new registered user. 
         * @summary Resend Sign Up Confirmation Email
         * @param {ResendSignUpConfirmationEmailParam} [resendSignUpConfirmationEmailParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendSignUpConfirmationEmail(resendSignUpConfirmationEmailParam?: ResendSignUpConfirmationEmailParam, options?: any): AxiosPromise<void> {
            return localVarFp.resendSignUpConfirmationEmail(resendSignUpConfirmationEmailParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new user. A temporary password will be sent to the registered email. 
         * @summary Sign Up
         * @param {SignUpParam} [signUpParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp(signUpParam?: SignUpParam, options?: any): AxiosPromise<SaasUser> {
            return localVarFp.signUp(signUpParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new user linked to AWS Marketplace. A temporary password will be sent to the registered email. If the Registration Token is not valid, an error is returned. 
         * @summary Sign Up with AWS Marketplace
         * @param {SignUpWithAwsMarketplaceParam} [signUpWithAwsMarketplaceParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpWithAwsMarketplace(signUpWithAwsMarketplaceParam?: SignUpWithAwsMarketplaceParam, options?: any): AxiosPromise<SaasUser> {
            return localVarFp.signUpWithAwsMarketplace(signUpWithAwsMarketplaceParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlink external identity providers. 
         * @summary Unlink external identity providers
         * @param {string} providerName 
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkProvider(providerName: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unlinkProvider(providerName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the additional attributes of the SaaS user. 
         * @summary Update SaaS User Attributes
         * @param {string} userId User ID
         * @param {UpdateSaasUserAttributesParam} [updateSaasUserAttributesParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSaasUserAttributes(userId: string, updateSaasUserAttributesParam?: UpdateSaasUserAttributesParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateSaasUserAttributes(userId, updateSaasUserAttributesParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s email. 
         * @summary Change Email
         * @param {string} userId User ID
         * @param {UpdateSaasUserEmailParam} [updateSaasUserEmailParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSaasUserEmail(userId: string, updateSaasUserEmailParam?: UpdateSaasUserEmailParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateSaasUserEmail(userId, updateSaasUserEmailParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Change user\'s login password. 
         * @summary Change Password
         * @param {string} userId User ID
         * @param {UpdateSaasUserPasswordParam} [updateSaasUserPasswordParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSaasUserPassword(userId: string, updateSaasUserPasswordParam?: UpdateSaasUserPasswordParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateSaasUserPassword(userId, updateSaasUserPasswordParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Register an authentication application. 
         * @summary Register Authentication Application
         * @param {string} userId User ID
         * @param {UpdateSoftwareTokenParam} [updateSoftwareTokenParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSoftwareToken(userId: string, updateSoftwareTokenParam?: UpdateSoftwareTokenParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateSoftwareToken(userId, updateSoftwareTokenParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user\'s MFA settings. 
         * @summary Update User\'s MFA Settings
         * @param {string} userId User ID
         * @param {MfaPreference} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserMfaPreference(userId: string, body?: MfaPreference, options?: any): AxiosPromise<void> {
            return localVarFp.updateUserMfaPreference(userId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SaasUserApi - object-oriented interface
 * @export
 * @class SaasUserApi
 * @extends {BaseAPI}
 */
export class SaasUserApi extends BaseAPI {
    /**
     * Verify the code to confirm the user\'s email address update. Requires the user\'s access token. 
     * @summary Confirm User Email Update
     * @param {string} userId User ID
     * @param {ConfirmEmailUpdateParam} [confirmEmailUpdateParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public confirmEmailUpdate(userId: string, confirmEmailUpdateParam?: ConfirmEmailUpdateParam, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).confirmEmailUpdate(userId, confirmEmailUpdateParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify the code for external account user link confirmation. 
     * @summary Confirm External User Account Link
     * @param {ConfirmExternalUserLinkParam} [confirmExternalUserLinkParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public confirmExternalUserLink(confirmExternalUserLinkParam?: ConfirmExternalUserLinkParam, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).confirmExternalUserLink(confirmExternalUserLinkParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirm a new use registeration linked to AWS Marketplace. Create a new tenant linked to AWS Marketplace. If the Registration Token is not valid, an error is returned. 
     * @summary Confirm Sign Up with AWS Marketplace
     * @param {ConfirmSignUpWithAwsMarketplaceParam} [confirmSignUpWithAwsMarketplaceParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public confirmSignUpWithAwsMarketplace(confirmSignUpWithAwsMarketplaceParam?: ConfirmSignUpWithAwsMarketplaceParam, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).confirmSignUpWithAwsMarketplace(confirmSignUpWithAwsMarketplaceParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create SaaS User. If attributes is empty, a temporary password will be sent to the registered email. 
     * @summary Create SaaS User
     * @param {CreateSaasUserParam} [createSaasUserParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public createSaasUser(createSaasUserParam?: CreateSaasUserParam, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).createSaasUser(createSaasUserParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a secret code for authentication application registration. 
     * @summary Create secret code for authentication application registration
     * @param {string} userId User ID
     * @param {CreateSecretCodeParam} [createSecretCodeParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public createSecretCode(userId: string, createSecretCodeParam?: CreateSecretCodeParam, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).createSecretCode(userId, createSecretCodeParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete all users with matching user ID from the tenant and SaaS. 
     * @summary Delete User
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public deleteSaasUser(userId: string, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).deleteSaasUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user information based on user ID. 
     * @summary Get User
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public getSaasUser(userId: string, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).getSaasUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all SaaS users. 
     * @summary Get Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public getSaasUsers(options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).getSaasUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the user\'s MFA settings. 
     * @summary Get User\'s MFA Settings
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public getUserMfaPreference(userId: string, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).getUserMfaPreference(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Link an existing tenant with AWS Marketplace. If the Registration Token is not valid, an error is returned. 
     * @summary Link an existing tenant with AWS Marketplace
     * @param {LinkAwsMarketplaceParam} [linkAwsMarketplaceParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public linkAwsMarketplace(linkAwsMarketplaceParam?: LinkAwsMarketplaceParam, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).linkAwsMarketplace(linkAwsMarketplaceParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request to update the user\'s email address. Sends a verification code to the requested email address. Requires the user\'s access token. The verification code is valid for 24 hours. 
     * @summary Request User Email Update
     * @param {string} userId User ID
     * @param {RequestEmailUpdateParam} [requestEmailUpdateParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public requestEmailUpdate(userId: string, requestEmailUpdateParam?: RequestEmailUpdateParam, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).requestEmailUpdate(userId, requestEmailUpdateParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request to link an external account user. Get the email address of the user to be linked from the access token and send a verification code to that email address. The verification code is valid for 24 hours. 
     * @summary Request External User Account Link
     * @param {RequestExternalUserLinkParam} [requestExternalUserLinkParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public requestExternalUserLink(requestExternalUserLinkParam?: RequestExternalUserLinkParam, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).requestExternalUserLink(requestExternalUserLinkParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resend temporary password for the new registered user. 
     * @summary Resend Sign Up Confirmation Email
     * @param {ResendSignUpConfirmationEmailParam} [resendSignUpConfirmationEmailParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public resendSignUpConfirmationEmail(resendSignUpConfirmationEmailParam?: ResendSignUpConfirmationEmailParam, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).resendSignUpConfirmationEmail(resendSignUpConfirmationEmailParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new user. A temporary password will be sent to the registered email. 
     * @summary Sign Up
     * @param {SignUpParam} [signUpParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public signUp(signUpParam?: SignUpParam, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).signUp(signUpParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new user linked to AWS Marketplace. A temporary password will be sent to the registered email. If the Registration Token is not valid, an error is returned. 
     * @summary Sign Up with AWS Marketplace
     * @param {SignUpWithAwsMarketplaceParam} [signUpWithAwsMarketplaceParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public signUpWithAwsMarketplace(signUpWithAwsMarketplaceParam?: SignUpWithAwsMarketplaceParam, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).signUpWithAwsMarketplace(signUpWithAwsMarketplaceParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unlink external identity providers. 
     * @summary Unlink external identity providers
     * @param {string} providerName 
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public unlinkProvider(providerName: string, userId: string, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).unlinkProvider(providerName, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the additional attributes of the SaaS user. 
     * @summary Update SaaS User Attributes
     * @param {string} userId User ID
     * @param {UpdateSaasUserAttributesParam} [updateSaasUserAttributesParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public updateSaasUserAttributes(userId: string, updateSaasUserAttributesParam?: UpdateSaasUserAttributesParam, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).updateSaasUserAttributes(userId, updateSaasUserAttributesParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s email. 
     * @summary Change Email
     * @param {string} userId User ID
     * @param {UpdateSaasUserEmailParam} [updateSaasUserEmailParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public updateSaasUserEmail(userId: string, updateSaasUserEmailParam?: UpdateSaasUserEmailParam, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).updateSaasUserEmail(userId, updateSaasUserEmailParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change user\'s login password. 
     * @summary Change Password
     * @param {string} userId User ID
     * @param {UpdateSaasUserPasswordParam} [updateSaasUserPasswordParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public updateSaasUserPassword(userId: string, updateSaasUserPasswordParam?: UpdateSaasUserPasswordParam, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).updateSaasUserPassword(userId, updateSaasUserPasswordParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register an authentication application. 
     * @summary Register Authentication Application
     * @param {string} userId User ID
     * @param {UpdateSoftwareTokenParam} [updateSoftwareTokenParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public updateSoftwareToken(userId: string, updateSoftwareTokenParam?: UpdateSoftwareTokenParam, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).updateSoftwareToken(userId, updateSoftwareTokenParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user\'s MFA settings. 
     * @summary Update User\'s MFA Settings
     * @param {string} userId User ID
     * @param {MfaPreference} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SaasUserApi
     */
    public updateUserMfaPreference(userId: string, body?: MfaPreference, options?: AxiosRequestConfig) {
        return SaasUserApiFp(this.configuration).updateUserMfaPreference(userId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SingleTenantApi - axios parameter creator
 * @export
 */
export const SingleTenantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the CloudFormation stack activation link for Single Tenant. 
         * @summary Get CloudFormation Stack Launch Link For Single Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCloudFormationLaunchStackLinkForSingleTenant: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/single-tenant/cloudformation-launch-stack-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the settings of the single tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTenantSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/single-tenant/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates configuration information for single-tenant functionality Returns error if single tenant feature cannot be enabled. 
         * @summary Update configuration information for single-tenant functionality
         * @param {UpdateSingleTenantSettingsParam} [updateSingleTenantSettingsParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleTenantSettings: async (updateSingleTenantSettingsParam?: UpdateSingleTenantSettingsParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/single-tenant/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSingleTenantSettingsParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SingleTenantApi - functional programming interface
 * @export
 */
export const SingleTenantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SingleTenantApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the CloudFormation stack activation link for Single Tenant. 
         * @summary Get CloudFormation Stack Launch Link For Single Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCloudFormationLaunchStackLinkForSingleTenant(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudFormationLaunchStackLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCloudFormationLaunchStackLinkForSingleTenant(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve the settings of the single tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleTenantSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SingleTenantSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleTenantSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates configuration information for single-tenant functionality Returns error if single tenant feature cannot be enabled. 
         * @summary Update configuration information for single-tenant functionality
         * @param {UpdateSingleTenantSettingsParam} [updateSingleTenantSettingsParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleTenantSettings(updateSingleTenantSettingsParam?: UpdateSingleTenantSettingsParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleTenantSettings(updateSingleTenantSettingsParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SingleTenantApi - factory interface
 * @export
 */
export const SingleTenantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SingleTenantApiFp(configuration)
    return {
        /**
         * Get the CloudFormation stack activation link for Single Tenant. 
         * @summary Get CloudFormation Stack Launch Link For Single Tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCloudFormationLaunchStackLinkForSingleTenant(options?: any): AxiosPromise<CloudFormationLaunchStackLink> {
            return localVarFp.getCloudFormationLaunchStackLinkForSingleTenant(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the settings of the single tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleTenantSettings(options?: any): AxiosPromise<SingleTenantSettings> {
            return localVarFp.getSingleTenantSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates configuration information for single-tenant functionality Returns error if single tenant feature cannot be enabled. 
         * @summary Update configuration information for single-tenant functionality
         * @param {UpdateSingleTenantSettingsParam} [updateSingleTenantSettingsParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleTenantSettings(updateSingleTenantSettingsParam?: UpdateSingleTenantSettingsParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateSingleTenantSettings(updateSingleTenantSettingsParam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SingleTenantApi - object-oriented interface
 * @export
 * @class SingleTenantApi
 * @extends {BaseAPI}
 */
export class SingleTenantApi extends BaseAPI {
    /**
     * Get the CloudFormation stack activation link for Single Tenant. 
     * @summary Get CloudFormation Stack Launch Link For Single Tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleTenantApi
     */
    public getCloudFormationLaunchStackLinkForSingleTenant(options?: AxiosRequestConfig) {
        return SingleTenantApiFp(this.configuration).getCloudFormationLaunchStackLinkForSingleTenant(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the settings of the single tenant.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleTenantApi
     */
    public getSingleTenantSettings(options?: AxiosRequestConfig) {
        return SingleTenantApiFp(this.configuration).getSingleTenantSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates configuration information for single-tenant functionality Returns error if single tenant feature cannot be enabled. 
     * @summary Update configuration information for single-tenant functionality
     * @param {UpdateSingleTenantSettingsParam} [updateSingleTenantSettingsParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleTenantApi
     */
    public updateSingleTenantSettings(updateSingleTenantSettingsParam?: UpdateSingleTenantSettingsParam, options?: AxiosRequestConfig) {
        return SingleTenantApiFp(this.configuration).updateSingleTenantSettings(updateSingleTenantSettingsParam, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TenantApi - axios parameter creator
 * @export
 */
export const TenantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a tenant managed by the SaaSus Platform. 
         * @summary Create Tenant
         * @param {TenantProps} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant: async (body?: TenantProps, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set Stripe initial information via billing 
         * @summary Stripe Initial Setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenantAndPricing: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete customer and product from Stripe. 
         * @summary Delete Customer and Product From Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStripeTenantAndPricing: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete SaaSus Platform tenant. 
         * @summary Delete Tenant
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenant: async (tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('deleteTenant', 'tenantId', tenantId)
            const localVarPath = `/tenants/{tenant_id}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the Stripe Customer information associated with the tenant, including their subscriptions. 
         * @summary Get Stripe Customer
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeCustomer: async (tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getStripeCustomer', 'tenantId', tenantId)
            const localVarPath = `/tenants/{tenant_id}/stripe-customer`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of tenant managed on the SaaSus Platform. 
         * @summary Get Tenant Details
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenant: async (tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getTenant', 'tenantId', tenantId)
            const localVarPath = `/tenants/{tenant_id}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sign-in information via external identity provider per tenant. 
         * @summary Get identity provider per tenant
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantIdentityProviders: async (tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getTenantIdentityProviders', 'tenantId', tenantId)
            const localVarPath = `/tenants/{tenant_id}/identity-providers`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get tenants managed by SaaSus Platform. 
         * @summary Get Tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenants: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all information related to rate plans. Delete plans linked to tenants and plan definitions. If you are using the Stripe linkage, the linkage will be removed. 
         * @summary Delete all information related to rate plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPlan: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/plans/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update SaaSus Platform tenant details. 
         * @summary Update Tenant Details
         * @param {string} tenantId Tenant ID
         * @param {TenantProps} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenant: async (tenantId: string, body?: TenantProps, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('updateTenant', 'tenantId', tenantId)
            const localVarPath = `/tenants/{tenant_id}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update SaaSus Platform tenant billing information. 
         * @summary Update Tenant Billing Information
         * @param {string} tenantId Tenant ID
         * @param {BillingInfo} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenantBillingInfo: async (tenantId: string, body?: BillingInfo, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('updateTenantBillingInfo', 'tenantId', tenantId)
            const localVarPath = `/tenants/{tenant_id}/billing-info`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update sign-in information via external identity provider per tenant. 
         * @summary Update identity provider per tenant
         * @param {string} tenantId Tenant ID
         * @param {UpdateTenantIdentityProviderParam} [updateTenantIdentityProviderParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenantIdentityProvider: async (tenantId: string, updateTenantIdentityProviderParam?: UpdateTenantIdentityProviderParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('updateTenantIdentityProvider', 'tenantId', tenantId)
            const localVarPath = `/tenants/{tenant_id}/identity-providers`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTenantIdentityProviderParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update SaaSus Platform tenant plan information. 
         * @summary Update Tenant Plan Information
         * @param {string} tenantId Tenant ID
         * @param {PlanReservation} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenantPlan: async (tenantId: string, body?: PlanReservation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('updateTenantPlan', 'tenantId', tenantId)
            const localVarPath = `/tenants/{tenant_id}/plans`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantApi - functional programming interface
 * @export
 */
export const TenantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TenantApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a tenant managed by the SaaSus Platform. 
         * @summary Create Tenant
         * @param {TenantProps} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTenant(body?: TenantProps, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTenant(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set Stripe initial information via billing 
         * @summary Stripe Initial Setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTenantAndPricing(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTenantAndPricing(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete customer and product from Stripe. 
         * @summary Delete Customer and Product From Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStripeTenantAndPricing(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStripeTenantAndPricing(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete SaaSus Platform tenant. 
         * @summary Delete Tenant
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTenant(tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTenant(tenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the Stripe Customer information associated with the tenant, including their subscriptions. 
         * @summary Get Stripe Customer
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStripeCustomer(tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeCustomer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStripeCustomer(tenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the details of tenant managed on the SaaSus Platform. 
         * @summary Get Tenant Details
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTenant(tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTenant(tenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get sign-in information via external identity provider per tenant. 
         * @summary Get identity provider per tenant
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTenantIdentityProviders(tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantIdentityProviders>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTenantIdentityProviders(tenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get tenants managed by SaaSus Platform. 
         * @summary Get Tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTenants(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenants>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTenants(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete all information related to rate plans. Delete plans linked to tenants and plan definitions. If you are using the Stripe linkage, the linkage will be removed. 
         * @summary Delete all information related to rate plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPlan(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPlan(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update SaaSus Platform tenant details. 
         * @summary Update Tenant Details
         * @param {string} tenantId Tenant ID
         * @param {TenantProps} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTenant(tenantId: string, body?: TenantProps, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTenant(tenantId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update SaaSus Platform tenant billing information. 
         * @summary Update Tenant Billing Information
         * @param {string} tenantId Tenant ID
         * @param {BillingInfo} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTenantBillingInfo(tenantId: string, body?: BillingInfo, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTenantBillingInfo(tenantId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update sign-in information via external identity provider per tenant. 
         * @summary Update identity provider per tenant
         * @param {string} tenantId Tenant ID
         * @param {UpdateTenantIdentityProviderParam} [updateTenantIdentityProviderParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTenantIdentityProvider(tenantId: string, updateTenantIdentityProviderParam?: UpdateTenantIdentityProviderParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTenantIdentityProvider(tenantId, updateTenantIdentityProviderParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update SaaSus Platform tenant plan information. 
         * @summary Update Tenant Plan Information
         * @param {string} tenantId Tenant ID
         * @param {PlanReservation} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTenantPlan(tenantId: string, body?: PlanReservation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTenantPlan(tenantId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TenantApi - factory interface
 * @export
 */
export const TenantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TenantApiFp(configuration)
    return {
        /**
         * Create a tenant managed by the SaaSus Platform. 
         * @summary Create Tenant
         * @param {TenantProps} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant(body?: TenantProps, options?: any): AxiosPromise<Tenant> {
            return localVarFp.createTenant(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Set Stripe initial information via billing 
         * @summary Stripe Initial Setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenantAndPricing(options?: any): AxiosPromise<void> {
            return localVarFp.createTenantAndPricing(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete customer and product from Stripe. 
         * @summary Delete Customer and Product From Stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStripeTenantAndPricing(options?: any): AxiosPromise<void> {
            return localVarFp.deleteStripeTenantAndPricing(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete SaaSus Platform tenant. 
         * @summary Delete Tenant
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenant(tenantId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTenant(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the Stripe Customer information associated with the tenant, including their subscriptions. 
         * @summary Get Stripe Customer
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeCustomer(tenantId: string, options?: any): AxiosPromise<StripeCustomer> {
            return localVarFp.getStripeCustomer(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of tenant managed on the SaaSus Platform. 
         * @summary Get Tenant Details
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenant(tenantId: string, options?: any): AxiosPromise<TenantDetail> {
            return localVarFp.getTenant(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get sign-in information via external identity provider per tenant. 
         * @summary Get identity provider per tenant
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantIdentityProviders(tenantId: string, options?: any): AxiosPromise<TenantIdentityProviders> {
            return localVarFp.getTenantIdentityProviders(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get tenants managed by SaaSus Platform. 
         * @summary Get Tenants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenants(options?: any): AxiosPromise<Tenants> {
            return localVarFp.getTenants(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all information related to rate plans. Delete plans linked to tenants and plan definitions. If you are using the Stripe linkage, the linkage will be removed. 
         * @summary Delete all information related to rate plans
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPlan(options?: any): AxiosPromise<void> {
            return localVarFp.resetPlan(options).then((request) => request(axios, basePath));
        },
        /**
         * Update SaaSus Platform tenant details. 
         * @summary Update Tenant Details
         * @param {string} tenantId Tenant ID
         * @param {TenantProps} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenant(tenantId: string, body?: TenantProps, options?: any): AxiosPromise<void> {
            return localVarFp.updateTenant(tenantId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update SaaSus Platform tenant billing information. 
         * @summary Update Tenant Billing Information
         * @param {string} tenantId Tenant ID
         * @param {BillingInfo} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenantBillingInfo(tenantId: string, body?: BillingInfo, options?: any): AxiosPromise<void> {
            return localVarFp.updateTenantBillingInfo(tenantId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update sign-in information via external identity provider per tenant. 
         * @summary Update identity provider per tenant
         * @param {string} tenantId Tenant ID
         * @param {UpdateTenantIdentityProviderParam} [updateTenantIdentityProviderParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenantIdentityProvider(tenantId: string, updateTenantIdentityProviderParam?: UpdateTenantIdentityProviderParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateTenantIdentityProvider(tenantId, updateTenantIdentityProviderParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Update SaaSus Platform tenant plan information. 
         * @summary Update Tenant Plan Information
         * @param {string} tenantId Tenant ID
         * @param {PlanReservation} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenantPlan(tenantId: string, body?: PlanReservation, options?: any): AxiosPromise<void> {
            return localVarFp.updateTenantPlan(tenantId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TenantApi - object-oriented interface
 * @export
 * @class TenantApi
 * @extends {BaseAPI}
 */
export class TenantApi extends BaseAPI {
    /**
     * Create a tenant managed by the SaaSus Platform. 
     * @summary Create Tenant
     * @param {TenantProps} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public createTenant(body?: TenantProps, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).createTenant(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set Stripe initial information via billing 
     * @summary Stripe Initial Setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public createTenantAndPricing(options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).createTenantAndPricing(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete customer and product from Stripe. 
     * @summary Delete Customer and Product From Stripe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public deleteStripeTenantAndPricing(options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).deleteStripeTenantAndPricing(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete SaaSus Platform tenant. 
     * @summary Delete Tenant
     * @param {string} tenantId Tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public deleteTenant(tenantId: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).deleteTenant(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the Stripe Customer information associated with the tenant, including their subscriptions. 
     * @summary Get Stripe Customer
     * @param {string} tenantId Tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getStripeCustomer(tenantId: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).getStripeCustomer(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of tenant managed on the SaaSus Platform. 
     * @summary Get Tenant Details
     * @param {string} tenantId Tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getTenant(tenantId: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).getTenant(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get sign-in information via external identity provider per tenant. 
     * @summary Get identity provider per tenant
     * @param {string} tenantId Tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getTenantIdentityProviders(tenantId: string, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).getTenantIdentityProviders(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get tenants managed by SaaSus Platform. 
     * @summary Get Tenants
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public getTenants(options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).getTenants(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete all information related to rate plans. Delete plans linked to tenants and plan definitions. If you are using the Stripe linkage, the linkage will be removed. 
     * @summary Delete all information related to rate plans
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public resetPlan(options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).resetPlan(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update SaaSus Platform tenant details. 
     * @summary Update Tenant Details
     * @param {string} tenantId Tenant ID
     * @param {TenantProps} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public updateTenant(tenantId: string, body?: TenantProps, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).updateTenant(tenantId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update SaaSus Platform tenant billing information. 
     * @summary Update Tenant Billing Information
     * @param {string} tenantId Tenant ID
     * @param {BillingInfo} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public updateTenantBillingInfo(tenantId: string, body?: BillingInfo, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).updateTenantBillingInfo(tenantId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update sign-in information via external identity provider per tenant. 
     * @summary Update identity provider per tenant
     * @param {string} tenantId Tenant ID
     * @param {UpdateTenantIdentityProviderParam} [updateTenantIdentityProviderParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public updateTenantIdentityProvider(tenantId: string, updateTenantIdentityProviderParam?: UpdateTenantIdentityProviderParam, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).updateTenantIdentityProvider(tenantId, updateTenantIdentityProviderParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update SaaSus Platform tenant plan information. 
     * @summary Update Tenant Plan Information
     * @param {string} tenantId Tenant ID
     * @param {PlanReservation} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public updateTenantPlan(tenantId: string, body?: PlanReservation, options?: AxiosRequestConfig) {
        return TenantApiFp(this.configuration).updateTenantPlan(tenantId, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TenantAttributeApi - axios parameter creator
 * @export
 */
export const TenantAttributeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Register additional tenant attributes to be managed by SaaSus Platform. For example, tenant name, memo, etc., then get the attributes from SaaS using the SaaSus SDK/API. 
         * @summary Create Tenant Attribute
         * @param {Attribute} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenantAttribute: async (body?: Attribute, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tenant-attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes tenant attributes managed by SaaSus Platform. 
         * @summary Delete Tenant Attribute
         * @param {string} attributeName Attribute Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenantAttribute: async (attributeName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeName' is not null or undefined
            assertParamExists('deleteTenantAttribute', 'attributeName', attributeName)
            const localVarPath = `/tenant-attributes/{attribute_name}`
                .replace(`{${"attribute_name"}}`, encodeURIComponent(String(attributeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get definitions for additional tenant attributes managed by the SaaSus Platform. For example, tenant name, memo, etc., then get the attributes from SaaS using the SaaSus SDK/API. 
         * @summary Get Tenant Attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantAttributes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tenant-attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantAttributeApi - functional programming interface
 * @export
 */
export const TenantAttributeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TenantAttributeApiAxiosParamCreator(configuration)
    return {
        /**
         * Register additional tenant attributes to be managed by SaaSus Platform. For example, tenant name, memo, etc., then get the attributes from SaaS using the SaaSus SDK/API. 
         * @summary Create Tenant Attribute
         * @param {Attribute} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTenantAttribute(body?: Attribute, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTenantAttribute(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes tenant attributes managed by SaaSus Platform. 
         * @summary Delete Tenant Attribute
         * @param {string} attributeName Attribute Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTenantAttribute(attributeName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTenantAttribute(attributeName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get definitions for additional tenant attributes managed by the SaaSus Platform. For example, tenant name, memo, etc., then get the attributes from SaaS using the SaaSus SDK/API. 
         * @summary Get Tenant Attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTenantAttributes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantAttributes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTenantAttributes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TenantAttributeApi - factory interface
 * @export
 */
export const TenantAttributeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TenantAttributeApiFp(configuration)
    return {
        /**
         * Register additional tenant attributes to be managed by SaaSus Platform. For example, tenant name, memo, etc., then get the attributes from SaaS using the SaaSus SDK/API. 
         * @summary Create Tenant Attribute
         * @param {Attribute} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenantAttribute(body?: Attribute, options?: any): AxiosPromise<Attribute> {
            return localVarFp.createTenantAttribute(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes tenant attributes managed by SaaSus Platform. 
         * @summary Delete Tenant Attribute
         * @param {string} attributeName Attribute Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenantAttribute(attributeName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTenantAttribute(attributeName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get definitions for additional tenant attributes managed by the SaaSus Platform. For example, tenant name, memo, etc., then get the attributes from SaaS using the SaaSus SDK/API. 
         * @summary Get Tenant Attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantAttributes(options?: any): AxiosPromise<TenantAttributes> {
            return localVarFp.getTenantAttributes(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TenantAttributeApi - object-oriented interface
 * @export
 * @class TenantAttributeApi
 * @extends {BaseAPI}
 */
export class TenantAttributeApi extends BaseAPI {
    /**
     * Register additional tenant attributes to be managed by SaaSus Platform. For example, tenant name, memo, etc., then get the attributes from SaaS using the SaaSus SDK/API. 
     * @summary Create Tenant Attribute
     * @param {Attribute} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantAttributeApi
     */
    public createTenantAttribute(body?: Attribute, options?: AxiosRequestConfig) {
        return TenantAttributeApiFp(this.configuration).createTenantAttribute(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes tenant attributes managed by SaaSus Platform. 
     * @summary Delete Tenant Attribute
     * @param {string} attributeName Attribute Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantAttributeApi
     */
    public deleteTenantAttribute(attributeName: string, options?: AxiosRequestConfig) {
        return TenantAttributeApiFp(this.configuration).deleteTenantAttribute(attributeName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get definitions for additional tenant attributes managed by the SaaSus Platform. For example, tenant name, memo, etc., then get the attributes from SaaS using the SaaSus SDK/API. 
     * @summary Get Tenant Attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantAttributeApi
     */
    public getTenantAttributes(options?: AxiosRequestConfig) {
        return TenantAttributeApiFp(this.configuration).getTenantAttributes(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TenantUserApi - axios parameter creator
 * @export
 */
export const TenantUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a tenant user. If attributes is empty, the additional attributes will be created empty. 
         * @summary Create Tenant User
         * @param {string} tenantId Tenant ID
         * @param {CreateTenantUserParam} [createTenantUserParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenantUser: async (tenantId: string, createTenantUserParam?: CreateTenantUserParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('createTenantUser', 'tenantId', tenantId)
            const localVarPath = `/tenants/{tenant_id}/users`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTenantUserParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create roles on tenant users. 
         * @summary Create Tenant User Role
         * @param {string} tenantId Tenant ID
         * @param {string} userId User ID
         * @param {number} envId Env ID
         * @param {CreateTenantUserRolesParam} [createTenantUserRolesParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenantUserRoles: async (tenantId: string, userId: string, envId: number, createTenantUserRolesParam?: CreateTenantUserRolesParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('createTenantUserRoles', 'tenantId', tenantId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createTenantUserRoles', 'userId', userId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('createTenantUserRoles', 'envId', envId)
            const localVarPath = `/tenants/{tenant_id}/users/{user_id}/envs/{env_id}/roles`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"env_id"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTenantUserRolesParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user from the tenant. 
         * @summary Delete Tenant User
         * @param {string} tenantId Tenant ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenantUser: async (tenantId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('deleteTenantUser', 'tenantId', tenantId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteTenantUser', 'userId', userId)
            const localVarPath = `/tenants/{tenant_id}/users/{user_id}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a role from a tenant user. 
         * @summary Remove Role From Tenant User
         * @param {string} tenantId Tenant ID
         * @param {string} userId User ID
         * @param {number} envId Env ID
         * @param {string} roleName Role name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenantUserRole: async (tenantId: string, userId: string, envId: number, roleName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('deleteTenantUserRole', 'tenantId', tenantId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteTenantUserRole', 'userId', userId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('deleteTenantUserRole', 'envId', envId)
            // verify required parameter 'roleName' is not null or undefined
            assertParamExists('deleteTenantUserRole', 'roleName', roleName)
            const localVarPath = `/tenants/{tenant_id}/users/{user_id}/envs/{env_id}/roles/{role_name}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"env_id"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"role_name"}}`, encodeURIComponent(String(roleName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information on user belonging to the tenant from the user ID. If the user belongs to multiple tenants, it will be returned as another object. 
         * @summary Get User Info
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTenantUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAllTenantUser', 'userId', userId)
            const localVarPath = `/tenants/all/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all users belonging to the tenant. The same user belonging to multiple tenants will be returned as a different object. Id is not unique. 
         * @summary Get Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTenantUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tenants/all/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get one tenant user by specific ID. 
         * @summary Get Tenant User
         * @param {string} tenantId Tenant ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantUser: async (tenantId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getTenantUser', 'tenantId', tenantId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getTenantUser', 'userId', userId)
            const localVarPath = `/tenants/{tenant_id}/users/{user_id}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the users belonging to the tenant. Id is unique. 
         * @summary Get Tenant Users
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantUsers: async (tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('getTenantUsers', 'tenantId', tenantId)
            const localVarPath = `/tenants/{tenant_id}/users`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update tenant user attributes. 
         * @summary Update Tenant User Attribute
         * @param {string} tenantId Tenant ID
         * @param {string} userId User ID
         * @param {UpdateTenantUserParam} [updateTenantUserParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenantUser: async (tenantId: string, userId: string, updateTenantUserParam?: UpdateTenantUserParam, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('updateTenantUser', 'tenantId', tenantId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateTenantUser', 'userId', userId)
            const localVarPath = `/tenants/{tenant_id}/users/{user_id}`
                .replace(`{${"tenant_id"}}`, encodeURIComponent(String(tenantId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTenantUserParam, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantUserApi - functional programming interface
 * @export
 */
export const TenantUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TenantUserApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a tenant user. If attributes is empty, the additional attributes will be created empty. 
         * @summary Create Tenant User
         * @param {string} tenantId Tenant ID
         * @param {CreateTenantUserParam} [createTenantUserParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTenantUser(tenantId: string, createTenantUserParam?: CreateTenantUserParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTenantUser(tenantId, createTenantUserParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create roles on tenant users. 
         * @summary Create Tenant User Role
         * @param {string} tenantId Tenant ID
         * @param {string} userId User ID
         * @param {number} envId Env ID
         * @param {CreateTenantUserRolesParam} [createTenantUserRolesParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTenantUserRoles(tenantId: string, userId: string, envId: number, createTenantUserRolesParam?: CreateTenantUserRolesParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTenantUserRoles(tenantId, userId, envId, createTenantUserRolesParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a user from the tenant. 
         * @summary Delete Tenant User
         * @param {string} tenantId Tenant ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTenantUser(tenantId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTenantUser(tenantId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a role from a tenant user. 
         * @summary Remove Role From Tenant User
         * @param {string} tenantId Tenant ID
         * @param {string} userId User ID
         * @param {number} envId Env ID
         * @param {string} roleName Role name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTenantUserRole(tenantId: string, userId: string, envId: number, roleName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTenantUserRole(tenantId, userId, envId, roleName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get information on user belonging to the tenant from the user ID. If the user belongs to multiple tenants, it will be returned as another object. 
         * @summary Get User Info
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTenantUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTenantUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all users belonging to the tenant. The same user belonging to multiple tenants will be returned as a different object. Id is not unique. 
         * @summary Get Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTenantUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTenantUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get one tenant user by specific ID. 
         * @summary Get Tenant User
         * @param {string} tenantId Tenant ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTenantUser(tenantId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTenantUser(tenantId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all the users belonging to the tenant. Id is unique. 
         * @summary Get Tenant Users
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTenantUsers(tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTenantUsers(tenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update tenant user attributes. 
         * @summary Update Tenant User Attribute
         * @param {string} tenantId Tenant ID
         * @param {string} userId User ID
         * @param {UpdateTenantUserParam} [updateTenantUserParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTenantUser(tenantId: string, userId: string, updateTenantUserParam?: UpdateTenantUserParam, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTenantUser(tenantId, userId, updateTenantUserParam, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TenantUserApi - factory interface
 * @export
 */
export const TenantUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TenantUserApiFp(configuration)
    return {
        /**
         * Create a tenant user. If attributes is empty, the additional attributes will be created empty. 
         * @summary Create Tenant User
         * @param {string} tenantId Tenant ID
         * @param {CreateTenantUserParam} [createTenantUserParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenantUser(tenantId: string, createTenantUserParam?: CreateTenantUserParam, options?: any): AxiosPromise<User> {
            return localVarFp.createTenantUser(tenantId, createTenantUserParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Create roles on tenant users. 
         * @summary Create Tenant User Role
         * @param {string} tenantId Tenant ID
         * @param {string} userId User ID
         * @param {number} envId Env ID
         * @param {CreateTenantUserRolesParam} [createTenantUserRolesParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenantUserRoles(tenantId: string, userId: string, envId: number, createTenantUserRolesParam?: CreateTenantUserRolesParam, options?: any): AxiosPromise<void> {
            return localVarFp.createTenantUserRoles(tenantId, userId, envId, createTenantUserRolesParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user from the tenant. 
         * @summary Delete Tenant User
         * @param {string} tenantId Tenant ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenantUser(tenantId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTenantUser(tenantId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a role from a tenant user. 
         * @summary Remove Role From Tenant User
         * @param {string} tenantId Tenant ID
         * @param {string} userId User ID
         * @param {number} envId Env ID
         * @param {string} roleName Role name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenantUserRole(tenantId: string, userId: string, envId: number, roleName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTenantUserRole(tenantId, userId, envId, roleName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information on user belonging to the tenant from the user ID. If the user belongs to multiple tenants, it will be returned as another object. 
         * @summary Get User Info
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTenantUser(userId: string, options?: any): AxiosPromise<Users> {
            return localVarFp.getAllTenantUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all users belonging to the tenant. The same user belonging to multiple tenants will be returned as a different object. Id is not unique. 
         * @summary Get Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTenantUsers(options?: any): AxiosPromise<Users> {
            return localVarFp.getAllTenantUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * Get one tenant user by specific ID. 
         * @summary Get Tenant User
         * @param {string} tenantId Tenant ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantUser(tenantId: string, userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.getTenantUser(tenantId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the users belonging to the tenant. Id is unique. 
         * @summary Get Tenant Users
         * @param {string} tenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantUsers(tenantId: string, options?: any): AxiosPromise<Users> {
            return localVarFp.getTenantUsers(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update tenant user attributes. 
         * @summary Update Tenant User Attribute
         * @param {string} tenantId Tenant ID
         * @param {string} userId User ID
         * @param {UpdateTenantUserParam} [updateTenantUserParam] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenantUser(tenantId: string, userId: string, updateTenantUserParam?: UpdateTenantUserParam, options?: any): AxiosPromise<void> {
            return localVarFp.updateTenantUser(tenantId, userId, updateTenantUserParam, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TenantUserApi - object-oriented interface
 * @export
 * @class TenantUserApi
 * @extends {BaseAPI}
 */
export class TenantUserApi extends BaseAPI {
    /**
     * Create a tenant user. If attributes is empty, the additional attributes will be created empty. 
     * @summary Create Tenant User
     * @param {string} tenantId Tenant ID
     * @param {CreateTenantUserParam} [createTenantUserParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantUserApi
     */
    public createTenantUser(tenantId: string, createTenantUserParam?: CreateTenantUserParam, options?: AxiosRequestConfig) {
        return TenantUserApiFp(this.configuration).createTenantUser(tenantId, createTenantUserParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create roles on tenant users. 
     * @summary Create Tenant User Role
     * @param {string} tenantId Tenant ID
     * @param {string} userId User ID
     * @param {number} envId Env ID
     * @param {CreateTenantUserRolesParam} [createTenantUserRolesParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantUserApi
     */
    public createTenantUserRoles(tenantId: string, userId: string, envId: number, createTenantUserRolesParam?: CreateTenantUserRolesParam, options?: AxiosRequestConfig) {
        return TenantUserApiFp(this.configuration).createTenantUserRoles(tenantId, userId, envId, createTenantUserRolesParam, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user from the tenant. 
     * @summary Delete Tenant User
     * @param {string} tenantId Tenant ID
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantUserApi
     */
    public deleteTenantUser(tenantId: string, userId: string, options?: AxiosRequestConfig) {
        return TenantUserApiFp(this.configuration).deleteTenantUser(tenantId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a role from a tenant user. 
     * @summary Remove Role From Tenant User
     * @param {string} tenantId Tenant ID
     * @param {string} userId User ID
     * @param {number} envId Env ID
     * @param {string} roleName Role name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantUserApi
     */
    public deleteTenantUserRole(tenantId: string, userId: string, envId: number, roleName: string, options?: AxiosRequestConfig) {
        return TenantUserApiFp(this.configuration).deleteTenantUserRole(tenantId, userId, envId, roleName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information on user belonging to the tenant from the user ID. If the user belongs to multiple tenants, it will be returned as another object. 
     * @summary Get User Info
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantUserApi
     */
    public getAllTenantUser(userId: string, options?: AxiosRequestConfig) {
        return TenantUserApiFp(this.configuration).getAllTenantUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all users belonging to the tenant. The same user belonging to multiple tenants will be returned as a different object. Id is not unique. 
     * @summary Get Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantUserApi
     */
    public getAllTenantUsers(options?: AxiosRequestConfig) {
        return TenantUserApiFp(this.configuration).getAllTenantUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get one tenant user by specific ID. 
     * @summary Get Tenant User
     * @param {string} tenantId Tenant ID
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantUserApi
     */
    public getTenantUser(tenantId: string, userId: string, options?: AxiosRequestConfig) {
        return TenantUserApiFp(this.configuration).getTenantUser(tenantId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all the users belonging to the tenant. Id is unique. 
     * @summary Get Tenant Users
     * @param {string} tenantId Tenant ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantUserApi
     */
    public getTenantUsers(tenantId: string, options?: AxiosRequestConfig) {
        return TenantUserApiFp(this.configuration).getTenantUsers(tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update tenant user attributes. 
     * @summary Update Tenant User Attribute
     * @param {string} tenantId Tenant ID
     * @param {string} userId User ID
     * @param {UpdateTenantUserParam} [updateTenantUserParam] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantUserApi
     */
    public updateTenantUser(tenantId: string, userId: string, updateTenantUserParam?: UpdateTenantUserParam, options?: AxiosRequestConfig) {
        return TenantUserApiFp(this.configuration).updateTenantUser(tenantId, userId, updateTenantUserParam, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserAttributeApi - axios parameter creator
 * @export
 */
export const UserAttributeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create additional SaaS user attributes to be kept on the SaaSus Platform. You can give common values to all tenants. 
         * @summary Create SaaS User Attributes
         * @param {Attribute} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSaasUserAttribute: async (body?: Attribute, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/saas-user-attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create additional user attributes to be kept on the SaaSus Platform. You can give different values to each tenant. For example, you can define items associated with a user, such as user name, birthday, etc. If you don\'t want personal information on the SaaS Platform side, personal information can be kept on the SaaS side without user attribute definition. 
         * @summary Create User Attributes
         * @param {Attribute} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAttribute: async (body?: Attribute, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete user attributes kept on the SaaSus Platform. 
         * @summary Delete User Attribute
         * @param {string} attributeName Attribute Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAttribute: async (attributeName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeName' is not null or undefined
            assertParamExists('deleteUserAttribute', 'attributeName', attributeName)
            const localVarPath = `/user-attributes/{attribute_name}`
                .replace(`{${"attribute_name"}}`, encodeURIComponent(String(attributeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get additional attributes of the user saved in the SaaSus Platform. For example, you can define items associated with a user, such as user name, birthday, etc. If you don\'t want personal information on the SaaS Platform side, personal information can be kept on the SaaS side without user attribute definition. 
         * @summary Get User Attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAttributes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-attributes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserAttributeApi - functional programming interface
 * @export
 */
export const UserAttributeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserAttributeApiAxiosParamCreator(configuration)
    return {
        /**
         * Create additional SaaS user attributes to be kept on the SaaSus Platform. You can give common values to all tenants. 
         * @summary Create SaaS User Attributes
         * @param {Attribute} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSaasUserAttribute(body?: Attribute, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSaasUserAttribute(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create additional user attributes to be kept on the SaaSus Platform. You can give different values to each tenant. For example, you can define items associated with a user, such as user name, birthday, etc. If you don\'t want personal information on the SaaS Platform side, personal information can be kept on the SaaS side without user attribute definition. 
         * @summary Create User Attributes
         * @param {Attribute} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserAttribute(body?: Attribute, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attribute>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAttribute(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete user attributes kept on the SaaSus Platform. 
         * @summary Delete User Attribute
         * @param {string} attributeName Attribute Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserAttribute(attributeName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserAttribute(attributeName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get additional attributes of the user saved in the SaaSus Platform. For example, you can define items associated with a user, such as user name, birthday, etc. If you don\'t want personal information on the SaaS Platform side, personal information can be kept on the SaaS side without user attribute definition. 
         * @summary Get User Attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAttributes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAttributes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAttributes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserAttributeApi - factory interface
 * @export
 */
export const UserAttributeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserAttributeApiFp(configuration)
    return {
        /**
         * Create additional SaaS user attributes to be kept on the SaaSus Platform. You can give common values to all tenants. 
         * @summary Create SaaS User Attributes
         * @param {Attribute} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSaasUserAttribute(body?: Attribute, options?: any): AxiosPromise<Attribute> {
            return localVarFp.createSaasUserAttribute(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create additional user attributes to be kept on the SaaSus Platform. You can give different values to each tenant. For example, you can define items associated with a user, such as user name, birthday, etc. If you don\'t want personal information on the SaaS Platform side, personal information can be kept on the SaaS side without user attribute definition. 
         * @summary Create User Attributes
         * @param {Attribute} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAttribute(body?: Attribute, options?: any): AxiosPromise<Attribute> {
            return localVarFp.createUserAttribute(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete user attributes kept on the SaaSus Platform. 
         * @summary Delete User Attribute
         * @param {string} attributeName Attribute Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAttribute(attributeName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserAttribute(attributeName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get additional attributes of the user saved in the SaaSus Platform. For example, you can define items associated with a user, such as user name, birthday, etc. If you don\'t want personal information on the SaaS Platform side, personal information can be kept on the SaaS side without user attribute definition. 
         * @summary Get User Attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAttributes(options?: any): AxiosPromise<UserAttributes> {
            return localVarFp.getUserAttributes(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserAttributeApi - object-oriented interface
 * @export
 * @class UserAttributeApi
 * @extends {BaseAPI}
 */
export class UserAttributeApi extends BaseAPI {
    /**
     * Create additional SaaS user attributes to be kept on the SaaSus Platform. You can give common values to all tenants. 
     * @summary Create SaaS User Attributes
     * @param {Attribute} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAttributeApi
     */
    public createSaasUserAttribute(body?: Attribute, options?: AxiosRequestConfig) {
        return UserAttributeApiFp(this.configuration).createSaasUserAttribute(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create additional user attributes to be kept on the SaaSus Platform. You can give different values to each tenant. For example, you can define items associated with a user, such as user name, birthday, etc. If you don\'t want personal information on the SaaS Platform side, personal information can be kept on the SaaS side without user attribute definition. 
     * @summary Create User Attributes
     * @param {Attribute} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAttributeApi
     */
    public createUserAttribute(body?: Attribute, options?: AxiosRequestConfig) {
        return UserAttributeApiFp(this.configuration).createUserAttribute(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete user attributes kept on the SaaSus Platform. 
     * @summary Delete User Attribute
     * @param {string} attributeName Attribute Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAttributeApi
     */
    public deleteUserAttribute(attributeName: string, options?: AxiosRequestConfig) {
        return UserAttributeApiFp(this.configuration).deleteUserAttribute(attributeName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get additional attributes of the user saved in the SaaSus Platform. For example, you can define items associated with a user, such as user name, birthday, etc. If you don\'t want personal information on the SaaS Platform side, personal information can be kept on the SaaS side without user attribute definition. 
     * @summary Get User Attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAttributeApi
     */
    public getUserAttributes(options?: AxiosRequestConfig) {
        return UserAttributeApiFp(this.configuration).getUserAttributes(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserInfoApi - axios parameter creator
 * @export
 */
export const UserInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User information is obtained based on the ID token of the SaaS user (registered user). The ID token is passed to the Callback URL during login from the SaaSus Platform generated login screen. User information can be obtained from calling this API with an ID token from the URL on the server side. Since the acquired tenant, role (role), price plan, etc. are included, it is possible to implement authorization based on it. 
         * @summary Get User Info
         * @param {string} token ID Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getUserInfo', 'token', token)
            const localVarPath = `/userinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user information by email address. 
         * @summary Get User Info by Email
         * @param {string} email Email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoByEmail: async (email: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('getUserInfoByEmail', 'email', email)
            const localVarPath = `/userinfo/search/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserInfoApi - functional programming interface
 * @export
 */
export const UserInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * User information is obtained based on the ID token of the SaaS user (registered user). The ID token is passed to the Callback URL during login from the SaaSus Platform generated login screen. User information can be obtained from calling this API with an ID token from the URL on the server side. Since the acquired tenant, role (role), price plan, etc. are included, it is possible to implement authorization based on it. 
         * @summary Get User Info
         * @param {string} token ID Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfo(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get user information by email address. 
         * @summary Get User Info by Email
         * @param {string} email Email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfoByEmail(email: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfoByEmail(email, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserInfoApi - factory interface
 * @export
 */
export const UserInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserInfoApiFp(configuration)
    return {
        /**
         * User information is obtained based on the ID token of the SaaS user (registered user). The ID token is passed to the Callback URL during login from the SaaSus Platform generated login screen. User information can be obtained from calling this API with an ID token from the URL on the server side. Since the acquired tenant, role (role), price plan, etc. are included, it is possible to implement authorization based on it. 
         * @summary Get User Info
         * @param {string} token ID Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(token: string, options?: any): AxiosPromise<UserInfo> {
            return localVarFp.getUserInfo(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user information by email address. 
         * @summary Get User Info by Email
         * @param {string} email Email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoByEmail(email: string, options?: any): AxiosPromise<UserInfo> {
            return localVarFp.getUserInfoByEmail(email, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserInfoApi - object-oriented interface
 * @export
 * @class UserInfoApi
 * @extends {BaseAPI}
 */
export class UserInfoApi extends BaseAPI {
    /**
     * User information is obtained based on the ID token of the SaaS user (registered user). The ID token is passed to the Callback URL during login from the SaaSus Platform generated login screen. User information can be obtained from calling this API with an ID token from the URL on the server side. Since the acquired tenant, role (role), price plan, etc. are included, it is possible to implement authorization based on it. 
     * @summary Get User Info
     * @param {string} token ID Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserInfoApi
     */
    public getUserInfo(token: string, options?: AxiosRequestConfig) {
        return UserInfoApiFp(this.configuration).getUserInfo(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user information by email address. 
     * @summary Get User Info by Email
     * @param {string} email Email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserInfoApi
     */
    public getUserInfoByEmail(email: string, options?: AxiosRequestConfig) {
        return UserInfoApiFp(this.configuration).getUserInfoByEmail(email, options).then((request) => request(this.axios, this.basePath));
    }
}


